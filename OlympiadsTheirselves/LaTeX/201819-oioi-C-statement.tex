\begin{problem}{Палички --- інтерактивна гра}{Стандартний вхід (клавіатура)}{Стандартний вихід (екран)}{1 сек}{64 Мб}\label{text:sticks-simple-begin}
\label{prob:201819-oioi-C-sticks-simple-interactive}

Є одна купка, яка спочатку містить $N$ паличок.
Двоє грають у таку гру.
Кожен з гравців на кожному своєму ході може забрати з купки або~1, або~2, або~3 палички.
Ніяких інших варіантів ходу нема. 
Ходять гравці по черзі, пропускати хід не~можна.
Виграє той, хто забирає останню паличку (можливо, разом із ще однією або ще двома).

Напишіть програму, яка інтерактивно гратиме за першого гравця. 

На початку, один раз, Ваша програма повинна прочитати одне ціле число в окремому рядку\nolinebreak[3] --- початкову кількість паличок $N$ (${1\,{\<}\,N\,{\<}\,12345}$).
Потім вона повинна повторювати такий цикл:
\begin{enumerate}
\item
Вивести єдине число в окремому рядку\nolinebreak[3] --- свій хід, тобто кількість паличок, які вона зараз забирає з купки.
Це\nolinebreak[3] повинно бути ціле число від~1 до~3, % причому 
не~більше за поточну кількість паличок у купці. 
\item
Якщо після цього купка стає порожньою, 
% вивести рядок із фразою ``\texttt{I~won!}''
вивести окремим рядком фразу ``\texttt{I~won!}''
(без лапок, символ-у-символ згідно зразку) і завершити роботу.
\item
Інакше, прочитати хід програми-суперниці, тобто кількість паличок, які вона зараз забирає з~купки (єдине ціле число, в окремому рядку).
Гарантовано, що хід допустимий (є цілим числом від~1 до~3 і не~перевищує поточного залишку паличок у купці).
Само собою, ця гарантія дійсна лише за умови, що Ваша програма правильно визначила, що гра ще~не~закінчилася.
\item
Якщо після цього купка стає порожньою, 
% вивести рядок із фразою ``\texttt{You~won...}''
вивести % окремим рядком 
фразу ``\texttt{You~won...}''
(без лапок, символ-у-символ згідно зразку) і завершити роботу.
\end{enumerate}
Все вищезгадане повинно повторюватися, доки\nolinebreak[3] не\nolinebreak[2] будуть забрані всі палички (тобто, доки якась із програм-гравців не~в\'{и}грає).
Програма-суперниця не~виводить фраз ``\texttt{I~won!}''\nolinebreak[3] / ``\texttt{You~won...}'' 
чи\nolinebreak[2] якихось їх аналогів.

Ця задача є інтерактивною: 
Ваша програма не~отримає всіх вхідних даних на~початку,
а~отримуватиме по~мірі виконання доуточнення, 
що залежатимуть від попередніх дій Вашої програми. 
Тим~не~менш, \begin{slshape}її перевірка буде
\underline{автоматичною}\end{slshape}. 
Тому, в~цій програмі, як і в програмах--роз\-в'\-яз\-ках інших задач, 
теж\nolinebreak[3] слід 
\emph{не}~<<організовувати діалог інтуїтивно зрозумілим чином>>,
а~чітко дотримуватися формату. Тільки це не~формат вхідного та вихідного файлів,
а~формат спілкування з~програмою, яка грає роль суперника.

Настійливо рекомендується, щоб Ваша програма після кожного свого виведення 
робила дію \verb"flush(output)"\nolinebreak[2] (Pascal), 
вона~ж \verb"cout.flush()"\nolinebreak[2] (C++), 
вона~ж \verb"fflush(stdout)"\nolinebreak[2] (C), 
вона~ж \verb"sys.stdout.flush()"\nolinebreak[2] (Python),
вона~ж \verb"System.out.flush()"\nolinebreak[2] (Java).
Це~істотно зменшує ризик, 
що~проміжна відповідь <<застрягне>> десь по~дорозі, 
не~дійшовши до програми-суперниці.


\Example

\noindent\begin{exampleSimpleThree}{5em}{5em}{10cm}{Примітки}
\exmp{5
~
2
~}{~
1
~
2
I won!}{\noindent\begin{minipage}[t]{10cm}
\setstretch{0.875}
У купці з самого початку 5 паличок.
Ваша програма забирає одну, лишається чотири;
програма-суперниця забирає дві, лишається дві;
Ваша програма забирає обидві, повідомляє про свій виграш і завершує роботу.
\end{minipage}}%
\end{exampleSimpleThree}


\Scoring

У~приблизно половині тестів Ваша програма матиме справу з ідеальною програмою-су\-пер\-ни\-цею, яка не~робить помилок.
У~іншій приблизно половині\nolinebreak[3] --- з різними програмами-су\-пер\-ни\-ця\-ми, які грати не~вміють\nolinebreak[3] --- тобто, роблять лише ходи, які дотримуються формальних вимог <<забирати лише від~1 до~3 паличок>> та <<забирати не~більше паличок, ніж реально~є у~купці>>, 
але\nolinebreak[2] можуть вибирати не~найкращий з допустимих ходів, дотримуючись кожна своїх власних уявлень про те, як краще грати в цю гру.
Буде оцінюватися 
як уміння Вашої програми виграти там, де це легко,
так і вміння Вашої програми достойно, згідно правил гри, програти, 
так і вміння Вашої програми скористатися (теж\nolinebreak[2] згідно правил) помилками чи іншими неадекватностями програми-суперниці, якщо такі будуть.

За будь-яке порушення правил гри з\nolinebreak[3] боку Вашої програми, відповідний тест оцінюватиметься як не~пройдений.

\end{problem}