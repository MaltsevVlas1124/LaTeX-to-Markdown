\Tutorial	В\nolinebreak[3] принципі, \emph{можна} вивести аналітичну формулу, але\nolinebreak[2] це\nolinebreak[1] потреб\'{у}є знань з\nolinebreak[3] теорії чисел (охочі можуть знайти, що таке \emph{кільце залишків за модулем} та \emph{мал\'{а} теорема Ферма}, і застосувати до цієї задачі). Все\nolinebreak[3] це було\nolinebreak[3] \emph{би} доцільним, \emph{якби} довжина ISBN-коду становила, наприклад, \mbox{сотні}\nolinebreak[1] \mbox{тисяч}, так що розглянутий далі простіший і значно більш <<програмістський>> (а\nolinebreak[3] не\nolinebreak[3] <<математичний>>) підхід працював\nolinebreak[3] \emph{би} надто довго.

А\nolinebreak[3] для 10~цифр підходить і значно простіший перебір, тобто перепробувати усі варіанти від~0\nolinebreak[1] до~9 і для кожного подивитися, чи\nolinebreak[3] виконується описана в\nolinebreak[3] умові правильність\nolinebreak[3] ISBN. Приклад реалізації див.\nolinebreak[1] \IdeOne{g3SbMb}. Правда, при різних правильних відповідях ця програма вивела~б усі, хоча на~олімпіадах треба виводити будь-яку одну. Насправді це неактуально, бо різні правильні відповіді неможливі (хто вивчав питання, згадані у попередньому абзаці, можуть це довести; решта можуть або\nolinebreak[3] повірити, або\nolinebreak[3] дописати у розв'язок \verb"break" для обривання циклу після виведення першої відповіді.)

Говорити про асимптотичну складність некоректно, бо нема того розміру вхідних даних, який міг~би прямувати до~$\infty$. \emph{Якби} довжина ISBN-коду становила довільне\nolinebreak[3] $N$ (але таке, щоб $N{+}1$ було простим, і\nolinebreak[3] щоб аналогічна сума добутків ділилася без остачі на\nolinebreak[2] $N{+}1$), можна було~\emph{би} сказати, що перебір має складність\nolinebreak[3] $\Theta(N^2)$, а\nolinebreak[3] теоретико-числовий розв'язок\nolinebreak[3] --- ${\Theta(N+\log{}N)}\dib{{=}}{\Theta(N)}$.

\myhrulefill

Ще \emph{може} бути проблемою формат вхідних даних, особливо для мало\-досвід\-чених користувачів~\mbox{С++}: \verb"cin>>a>>b" ніби читає в~\verb"a" те, що до пропуску, й у~\verb"b" те, що після; але\nolinebreak[3] в\nolinebreak[2] \emph{обох} випадках <<пробіл замінює найпершу цифру>> та <<\dots~най\-остан\-нішу~\dots>> всі\nolinebreak[3] 9\nolinebreak[1] осмислених цифр ідуть в~\verb"a". Може сп\'{а}сти на думку читати у циклі окремі \mbox{\verb"char"-и}; але при стандартних налаштуваннях \verb"cin>>c" (\verb"c"~---\nolinebreak[1] \mbox{типу}\nolinebreak[2] \verb"char") взагалі пропускає пропуски, і взнати його позицію неможливо. Один зі способів вирішення цієї проблеми\nolinebreak[3] --- перед читанням \mbox{\verb"char"-ів} викликати % метод
\verb"cin.unsetf(ios::skipws)", щоб пропуски та переведення рядка таки читались у ті \mbox{\verb"char"-и}. Інший\nolinebreak[3] --- використати функцію \verb"getline(cin,s)" (\verb"s"~---\nolinebreak[1] типу\nolinebreak[1] \verb"string"); вона (як\nolinebreak[2] і\nolinebreak[2] \verb"readln" мови Pascal) читає все, включаючи пробіли, до кінця рядка.

