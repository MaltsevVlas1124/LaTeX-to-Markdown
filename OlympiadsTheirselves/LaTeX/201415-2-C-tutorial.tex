\Tutorial	Тут треба акуратно писати досить велику, як для II\nolinebreak[3] етапу, програму, поєднуючи різні стандартні алгоритми. Але, не~зважаючи на страшну назву <<ко-ана\-гра\-мічно>> та інші громіздкості, тут не\nolinebreak[3] дуже-то й треба самому придумувати щось математичне. Якщо, звісно:

\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]

\item
знати стандартний алгоритм перевірки простоти числ\'{а};

\item
вміти \emph{або перевіряти, чи}\nolinebreak[2] ч\'{и}сла складаються з одних і тих с\'{а}мих цифр, \emph{або генерувати перестановки} послідовності\nolinebreak[3] цифр.

\end{itemize}

Cтандартний алгоритм перевірки простоти числ\'{а}~$n$ (при\nolinebreak[2] ${n\,{\>}\,2}$)\nolinebreak[3] --- пробувати ділити його на\nolinebreak[3] 2,\nolinebreak[2] 3,\nolinebreak[3] \dots, \verb"round"$(\sqrt{n})$, і\nolinebreak[3] якщо хоч раз поділилося без остачі\nolinebreak[3] --- число скл\'{а}дене, якщо % не\nolinebreak[3] поділилося 
ні~разу\nolinebreak[3] --- просте. Важливо перевіряти до\nolinebreak[2] кореня (а\nolinebreak[3] не\nolinebreak[2] до\nolinebreak[3] $n$ чи\nolinebreak[2] $n/2$), бо це значно менше (див.\nolinebreak[2] також стор.~\pageref{text:about-sqrt-n-in-divisors-list}).

Перевіряти, чи ч\'{и}сла складаються з одних і тих самих цифр у різному порядку, можна по-різному. Один з простих і зручних підходів\nolinebreak[3] --- відсортувати (наприклад, за\nolinebreak[3] неспаданням) цифри окремо одного з~них, окремо іншого, й порівняти отримані відсортовані послідовності (вони рівні тоді й тільки тоді, коли ч\'{и}сла складаються з одних і тих самих цифр). Оскільки кількість цифр дуже маленька, нема смислу використовувати quickSort чи подібні ефективні алгоритми сортування, доречнішим буде сортування вставками чи навіть бульбашкове.

Таким чином, схема алгоритму може бути приблизно такою. 
Функція (підпрограма) <<перевірити, чи~є число ко-анаграмічно-простим>> має вигляд:

\begin{enumerate}
\item
Створити копію цього числ\'{а}-аргумента у рядковому (\texttt{string}-овому) вигляді;
\item
Відсортувати цифри (символи рядка) за неспаданням;
\item
Перебрати усі числа з відповідною кількістю цифр, від 0\dots01 до 9\dots99, і для кожного з них:
\begin{enumerate}
\item
перетворити у рядок (знову як копію, щоб не псувати оригінал);
\item
теж відсортувати цифри числ\'{а} за неспаданням;
\item \label{item:201415-2-d-both-tests}
якщо відсортовані послідовності виявилися різними --- значить, поточне число не є перестановкою цифр досліджуваного числ\'{а} і його слід пропустити, а якщо однаковими --- запустити перевірку поточного числ\'{а} на простоту.
\end{enumerate}
Якщо перевірка у п.~\ref{item:201415-2-d-both-tests} хоча~б один раз виявила, що число просте\nolinebreak[3] --- функція в цілому має повернути результат <<число є ко-ана\-гра\-мічно-простим>>. Якщо жодного разу не~виявила\nolinebreak[3] --- результат <<не~є>>.
\end{enumerate}

Тепер лишається тільки перевіряти, чи\nolinebreak[3] є ко-ана\-гра\-мічно-простим сам\'{е} введене число~$n$, потім ${n\,{+}\,1}$, ${n\,{+}\,2}$,~\dots{} Приклад реалізації\nolinebreak[3] --- \IdeOne{mGI9hm}.

Для цієї реалізації дуже складно і\nolinebreak[3] вивести асимптотичну оцінку часу роботи, і\nolinebreak[3] використати цю асимптотику для оцінювання конкретного часу роботи в\nolinebreak[3] мілісекундах. Наприклад, зовсім не\nolinebreak[3] ясно, як оцінити кількість ітерацій самого зовнішнього циклу (скільки чисел $n$, ${n\,{+}\,1}$,~\dots{} треба перебрати, щоб гарантовано знайти ко-ана\-гра\-мічно-просте). У\nolinebreak[3] перевірці простот\'{и}, хоч і видно верхню межу циклу \verb"round(sqrt(n))", але ж розумна реалізація обриває цикл після першого знайденого дільника, і середня кількість ітерацій виявляється меншою (а\nolinebreak[3] наскільки\nolinebreak[3] --- не\nolinebreak[3] ясно); і так далі.

Програма може працювати швидше, якщо, замість перебору всіх чисел з відповідною кількістю цифр (від 0\dots01 до 9\dots99), відразу генерувати лише ті, що складаються з потрібного набору цифр. При обмеженні ${n\,{\<}\,9999}$ це неважливо, тож не~будемо описувати, як робити це вручну (охочі можуть знайти в літературі чи Інтернеті за назвою \emph{генерація перестановок}, англ. \emph{generate permutations}). У\nolinebreak[3] мові\nolinebreak[2] C++ така генерація є готова (функція \verb"next_permutation" бібліотеки \verb"algorithm").

