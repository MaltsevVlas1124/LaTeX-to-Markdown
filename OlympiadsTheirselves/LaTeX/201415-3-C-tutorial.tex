\def\veryLongExamplesFontSize{normalsize}

\Tutorial	Легенда задачі відірвана від життя, ці правила не~мають нічого спільного з реальною генерацією паролів. Тим\nolinebreak[2] не\nolinebreak[3] менш, будемо користуватися термінами <<пароль>> і <<номер паролю>>, раз вони введені в умові.

\MyParagraph{Позбудемось окремих статусів літер і цифр, перейшовши до єдиного алфавіту.}
Правила про порядок можна спростити до таких:
\begin{enumerate}
\item
будемо вважати алфавітом \texttt{A},~\texttt{B}, \texttt{C}, \texttt{D}, \texttt{E}, \texttt{F}, \texttt{G}, \texttt{H}, \texttt{I}, \texttt{J}, \texttt{K}, \texttt{L}, \texttt{M}, \texttt{N}, \texttt{O}, \texttt{P}, \texttt{Q}, \texttt{R}, \texttt{S}, \texttt{T}, \texttt{U}, \texttt{V}, \texttt{W}, \texttt{X}, \texttt{Y}, \texttt{Z}, \texttt{0}, \texttt{1}, \texttt{2}, \texttt{3}, \texttt{4}, \texttt{5}, \texttt{6}, \texttt{7},~\texttt{8},~\texttt{9} (с\'{а}ме в такому порядку);
\item
всер\'{е}дині кожного пароля (крім 1-символьних), кожен наступний символ мусить бути строго більшим за попередній (згідно алфавіту п.~1).
\end{enumerate}

Правила порівняння різних паролів не~міняються (але примітка <<літери менші за цифри>> тепер слідує з <<алфавітного порядку>>).

\MyParagraph{Частковий розв’язок на 76 балів (зі~100).}
Оскільки в умові сказано, що досить багато балів припадає на не дуже великі значення~$n$, можна писати перебір, тобто дійсно генерувати послідовно \mbox{1-й}, \mbox{2-й},\nolinebreak[3] \dots{} паролі аж до\nolinebreak[2] \mbox{$n$-го}. Виявляється, при цьому не\nolinebreak[3] дуже важко добитися, щоб генерувалися відразу лише допустимі (згідно з умовою задачі) паролі.

{

\def\tabbb{\hspace*{1em}}

Розглянемо простіший випадок. Нехай потрібно вивести послідовно пари (1,2), (1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,4), (3,5), (4,5), тобто пари з чисел від 1 до~5, щоб \mbox{2-й} елемент пари завжди був строго більшим за\nolinebreak[2] \mbox{1-й}. Це\nolinebreak[3] можна зробити за допомогою циклів та \texttt{if}-а, як у лівому стовпчику рис.~\ref{fig:check-or-gen-only-needed}. А~можна, як у правому, замінити \emph{перевірку} ${i{<}j}$ на \emph{задання лише потрібного} діапазону.

\vspace{-0.5\baselineskip}

\begin{figure}[h]
\begin{center}
\hrulefill\par
\begin{tabular}{l|l}
\begin{minipage}{13em}\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}for i:=1 to 5 do
\tabbb{}for j:=1 to 5 do
\tabbb\tabbb{}if i < j then
\tabbb\tabbb\tabbb{}writeln(i, ', ', j);\end{alltt}\end{small}\end{minipage}
&
\begin{minipage}{13em}\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}for i:=1 to 4 do
\tabbb{}for j:=i+1 to 5 do
\tabbb\tabbb{}writeln(i, ', ', j);\end{alltt}\end{small}\end{minipage}
\end{tabular}
\end{center}

\vspace{-0.75\baselineskip}

\caption{Два способи генерації однієї послідовності пар}\label{fig:check-or-gen-only-needed}
\end{figure} % TODO: перевірити верстку

\vspace{-0.75\baselineskip}

}

Для \mbox{2-х} вкладених циклів це  дрібна оптимізація ($\approx$ удвічі). Але якщо застосувати ту саму ідею до циклів більшої вкладеності, пришвидшення істотне: для п'яти вкладених циклів\nolinebreak[3] $\approx$сотні разів, для десяти\nolinebreak[3] --- $\approx$мільйони. (Доведення потреб\'{у}є знань комбінаторики, але\nolinebreak[1] не\nolinebreak[3] дуже глибоких, тож пропонується як вправа. До\nolinebreak[3] того\nolinebreak[3] ж, писати програму можна й без доведення\dots)

Приклад такого розв’язку --- \IdeOne{Xg6sKT}.
Це\nolinebreak[2] зовсім\nolinebreak[2] не\nolinebreak[3] взірець красоти й лаконічності. У~ньому легко допустити і важко шукати технічні помилки. Але він все ж набирає чимало балів.

\MyParagraph{Повний (100\%) розв’язок.}
Перш за все, загальна кількість $k$-сим\-воль\-них паролів рівна $C(36, k)$, де $C(n,k)$, воно~ж $C_n^k$ --- кількість \emph{сполучень} (рос. \emph{сочетания}, англ. \emph{combinations}) з~$n$ по~$k$. Це~так, бо з~36\nolinebreak[3] символів вибираються $k$ різних, і одні й ті самі вибрані символи не~можна переставляти місцями, бо дозволений лише порядок за зростанням (у~алфавіті \texttt{A},~\texttt{B},~\dots,~\texttt{Z}, \texttt{0},~\texttt{1},~\dots,~\texttt{9}).

Так що почнемо розв’язок з того, що взн\'{а}ємо довжину (кількість символів) шуканого пароля і його номер \emph{серед паролів цієї довжини}.

\begin{\veryLongExamplesFontSize}
\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]
\item[] Наприклад, прочитали у вхідних даних 2015.

\item Кіль-ть 1-символьних паролів ${C(36,1){=}36}$,\hspace{0.5em plus 1em} ${36{<}2015}$\nolinebreak[3] --- отже, у паролі більше одного символу, й номер серед (більш-ніж-1)-символьних ${2015-36=1979}$.

\item Кіль-ть 2-символьних паролів ${C(36,2){=}630}$,\hspace{0.5em plus 1em} ${630{<}1979}$\nolinebreak[3] --- отже, у паролі більше двох символів, і номер серед (більш-ніж-2)-символьних ${1979-630=1349}$.

\item Кіль-ть 3-символьних паролів ${C(36,3){=}7140}$,\hspace{0.5em plus 1em} ${7140{\>}1349}$\nolinebreak[3] --- отже, пароль 3-символьний, і\nolinebreak[3] його номер серед 3-символьних рівний~1349.

\end{itemize}
\end{\veryLongExamplesFontSize}

Узнавши довжину пароля та його номер серед паролів 
відповідної довжини, починаємо взнавати цей пароль символ за символом, зліва направо --- на тій підставі, що для кожного можливого початку можна взнавати (засобами комбінаторики) 
% (комбінаторно)
кількість паролів з таким початком і знову приймати рішення, чи\nolinebreak[3] цей початок треба пропустити (всі паролі з таким початком мають менші номери), чи\nolinebreak[3] використати (потрібний номер якраз потрапляє у діапазон).

\begin{\veryLongExamplesFontSize}
\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]
\item[] Продовжимо аналіз того самого прикладу (вхідний номер 2015, раніше з’ясовано, що його номер серед 3-символьних рівний 1349).

\item Кіль-ть 3-символьних паролів, що починаються з~\texttt{A}, рівна ${C(35,2) = 595}$, бо продовження % паролю 
2-символьне з 35 символів (від~\texttt{B} до~\texttt{9}). ${1349>595}$\nolinebreak[3] --- отже, початок паролю не~\texttt{A}, а\nolinebreak[2] якийсь подальший символ, і номер % паролю 
серед тих подальших ${1349-595=754}$.

\item Кіль-ть 3-символьних паролів, що починаються з~\texttt{B}, рівна ${C(34,2) = 561}$, бо продовження % паролю 
2-символьне з 34 символів (від~\texttt{C} до~\texttt{9}). ${754>561}$\nolinebreak[3] --- отже, початок паролю не~\texttt{B}, а\nolinebreak[2] якийсь подальший символ, і номер % паролю 
серед тих подальших ${754-561=193}$.

\item Кіль-ть 3-символьних паролів, що починаються з~\texttt{C}, рівна ${C(33,2) = 528}$, бо продовження % паролю 
2-символьне з 33 символів (від~\texttt{D} до~\texttt{9}). ${193\<528}$\nolinebreak[3] --- отже, початок паролю якраз-таки~\texttt{C}, і його номер серед 3-символьних, що\nolinebreak[3] починаються з~\texttt{C} --- теж~193.

\begin{itemize}[leftmargin=*,itemsep=0pt,partopsep=0pt,topsep=0pt,parsep=0pt]
\item[] Далі відбувається аналогічний підбір наступного символу:

\item[\textopenbullet] Кіль-ть 3-символьних паролів, що починаються з~``\texttt{CD}'', рівна ${C(32,1)=32}$, бо лишається дописати один символ, від~\texttt{E} до~\texttt{9}. ${193>32}$\nolinebreak[3] --- отже, 2-га літера не~\texttt{D}, а\nolinebreak[3] якийсь подальший символ, і номер % паролю 
серед тих подальших ${193-32=161}$.

\item[$\isdiv$] І так далі.

\item[\textopenbullet] Продовживши аналогічні міркування, отримаємо, що шуканий пароль \mbox{16-й} серед тих, що починаються з~``\texttt{CJ}'', а оскільки після~\texttt{J} можуть іти лише символи, починаючи з~\texttt{K}, то цим 16-м буде~\texttt{Z}.
\end{itemize}

\item[!] Остат\'{о}чно, 2015-й пароль має вигляд ``\texttt{CJZ}''.
\end{itemize}
\end{\veryLongExamplesFontSize}

Ці пояснення займають багато місця, але лише тому, що наведено приклад. Правильна реалізація цього комбінаторного алгоритму працює дуже швидко, вкладаючись у секунду з величезним запасом. Адже всього-то треба:

\begin{enumerate}

\item
Познаходити $C(n,k)$, наприклад, усі зразу із проміжку $0\dib{{\<}}k\dib{{\<}}n\dib{{\<}}36$ за допомогою трикутника Паскаля;

\item
Знайти кількість символів у паролі --- віднімати циклом $C(36,1)$, $C(36,2)$,~\dots; якби дійшли до $C(36,36))$, а\nolinebreak[3] номер після усіх віднімань все ще лишався надто великим --- це означало~б, що пароля вказаних вигляду і номера взагалі\nolinebreak[2] не~існує. Але такого не~буде, бо паролів ($2^{36}-1$) все-таки більше, чим $n{\<}10^{10}$. Значить --- тут % взагалі 
не~більш як 36 порівнянь та віднімань;

\item
Для кожної позиції (1-й\nolinebreak[3] символ, 2-й,~\dots) запустити цикл, щоб знайти конкретне значення відповідного символу\nolinebreak[3] --- теж\nolinebreak[3] не~багато, бо і\nolinebreak[3] позицій, і\nolinebreak[3] значень символів не~більше~36.

\end{enumerate}

Від вираження асимптотичної оцінки складності алгоритму типовим чином (через $n$ зі вхідних даних) утримаємось, бо надто багато залежить від розміру алфавіту, а залежність часу роботи від значення~$n$ заплутана.
\emph{Якби} розмір алфавіту був змінним (і при цьому не~з'являлася <<довга>> арифметика), можна було~б говорити про час роботи $O(A^2)$, де\nolinebreak[3] $A$\nolinebreak[3] --- розмір алфавіту. 
% % % При $A{=}36$, це \emph{дуже} швидко\dots
\label{label:201415-3-C-finish}


