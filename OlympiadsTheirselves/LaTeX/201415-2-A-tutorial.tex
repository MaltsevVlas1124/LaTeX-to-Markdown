\Tutorial	{
\hyphenpenalty=400
Діяти за принципом \textsl{<<Викреслювати мінімальну цифру>>} \emph{неправильно} (всупереч підступним пр\'{и}\-кла\-дам з~умови, які провокують таку хибну думку.) Наприклад, із\nolinebreak[2] числ\'{а}\nolinebreak[3] 9891 треба викреслити~8 і отримати~991, а\nolinebreak[3] викреслення мінімальної цифри~1 дасть не~максимальне~989.

}

Оскільки розміри малі (кількість цифр$\dib{{\<}}$5, видаляється одна), 
% найпростіший правильний розв’язок\nolinebreak[3] --- 
можна просто
перебрати всі варіанти викреслення однієї цифри (усе число без\nolinebreak[3] \mbox{1-ої}, усе без\nolinebreak[3] \mbox{2-ої}, тощо), і~вибрати з~них максимальний. Зручно (хоча й не~обов'язково) перевести число у\nolinebreak[3] рядок (\verb"string"), і~вилучати символи у\nolinebreak[3] рядковому поданні. Реалізацію див. \IdeOne{jFBIM6}.
При бажанні, її можна спростити, роблячи все виключно рядками. (Взагалі буває проблема <<у~числах ${7{<}10}$, а\nolinebreak[3] у\nolinebreak[3] рядках \verb|"7"|$\dib{{>}}$\verb|"10"|>>, але \emph{тут} вона не~проявиться, бо кількості цифр усіх потрібних чисел однакові.)

Якщо мати лише мету розв'язати цю задачу при цих обмеженнях\nolinebreak[3] --- краще обмежитися першим правильним способом і не\nolinebreak[3] читати далі. А\nolinebreak[3] якщо мати бажання ще\nolinebreak[2] раз розглянути, як можна доводити правильність алгоритма (див.\nolinebreak[3] також стор.~\pageref{text:need-or-no-need-to-prove})\nolinebreak[3] --- тоді подальший текст важливий. 

Ще є правильний розв’язок \textsl{<<Знайти найлівіше місце, де зразу після меншої цифри йде більша, і викреслити меншу с\'{а}ме з\nolinebreak[2] цих двох; якщо жодного такого місця нема (наприклад, у\nolinebreak[3] числі\nolinebreak[2] 97752) --- викреслити останню цифру>>}.

\phantomsection\label{text:proof-max-num-by-strike-out-one-digit}
Занумеруємо цифри початкового числ\'{а} зліва направо $\overline{a_1a_2\dots{}a_n}$.
Розглянемо спочатку випадок <<нема жодного місця, щоб після меншої цифри йшла більша>>, тобто $a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_n$. Згідно алгоритму, треба викреслити~$a_n$, лишивши $\overline{a_1a_2\dots{}a_{n-1}}$. Якщо всупереч алгоритму викреслити деяку~$a_j$ ($1{\<}j{<}n$), вийде $\overline{a_1a_2\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}$. Початок $\overline{a_1a_2\dots{}a_{j-1}}$ спільний, 
% тож при порівнянні буде пропущений, фактично будуть порівнюватися частини, де
тож результат порівняння визначається частиною, де
$a_{j+1}$\nolinebreak[1] замість\nolinebreak[3] $a_j$,\linebreak[1] 
$a_{j+2}$\nolinebreak[2] замість\nolinebreak[3] $a_{j+1}$,
\dots,\linebreak[1]
$a_{n}$\nolinebreak[2] замість\nolinebreak[3] $a_{n-1}$.
Оскільки розглядаємо ситуацію $a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_n$, то або ${a_j{>}a_{j+1}}$, або ${a_j{=}a_{j+1}}$. При $a_j\dib{{>}}a_{j+1}$, число, отримане всупереч алгоритму, менше (гірше) отриманого згідно з алгоритмом, бо після спільного початку йде $a_{j+1}\dib{{<}}a_j$. Якщо ж $a_j\dib{{=}}a_{j+1}$, то можна приєднати цю цифру до спільного початку і повторити \emph{всі} міркування для <<$a_{j+2}$\nolinebreak[1] замість\nolinebreak[3] $a_{j+1}$>>. І\nolinebreak[3] так\nolinebreak[2] \mbox{далі}. Кінець кінцем, або десь отримаємо, що число всупереч алгоритму менше (гірше) числ\'{а} згідно з алгоритмом, або дійдемо до $a_j\dib{{=}}a_{j+1}\dib{{=}}\dots\dib{{=}}a_n$, тобто викреслення~$a_j$ призводить до \emph{того~ж} результату, що алгоритм. 

Лишилося розглянути випадок, коли місце, де\nolinebreak[3] $a_i{<}a_{i+1}$, існує. Нехай $i^{\star}$\nolinebreak[3] --- найлівіша з таких позицій, тобто $a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_{i^{\star}}$ і $(a_{i^{\star}}{<}a_{i^{\star}+1})$. Невигідність видаляти замість~$a_{i^{\star}}$ деяку $a_j$ при $1{\<}j{<}i^{\star}$ доводиться аналогічно попередньому абзацу. Лишилося довести невигідність видаляти $a_j$ при $i^{\star}{<}j{\<}n$, а це зовсім легко: згідно з алгоритмом отримуємо $\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}+1}\dots{}a_{n}}$, всупереч\nolinebreak[3] --- $\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}}\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}$, тобто початок $\overline{a_1a_2\dots{}a_{i^{\star}-1}}$ спільний, потім ${a_{i^{\star}+1} > a_{i^{\star}}}$. Розглянуті випадки покрили всі можливі ситуації, доведення успішно завершене.

\vspace{0.125\baselineskip plus 1ex}
\myhrulefill
\vspace{0.125\baselineskip plus 1ex}

Чи має др\'{у}гий алгоритм переваги над першим? При ${n{\<}99999}$\nolinebreak[3] --- ні. \emph{Якби} ч\'{и}сла були значно більшими (наприклад, до мільйона цифр; не~<<$n{\<}10^6$>>, а\nolinebreak[2] якби \emph{кількість цифр} могла сягати мільйона)\nolinebreak[3] --- тоді виявилося\nolinebreak[3] б, що перший алгоритм правильний, але повільний, а др\'{у}гий правильний і ефективний. Асимптотичні оцінки: $\Theta(L^2)$ для першого, $\Theta(L)$ для др\'{у}гого, де $L$\nolinebreak[3] --- кількість цифр. % числ\'{а}~$n$.

