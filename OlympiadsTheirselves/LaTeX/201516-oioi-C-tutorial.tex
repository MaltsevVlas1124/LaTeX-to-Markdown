\Tutorial
Таке <<рівняння>> не~має стандартних аналітичних засобів розв'язування, тож справді треба якось перебирати різні потенційно можливі варіанти й перевіряти, які з них дають розв'язок. Але перебір <<в~лоб>> (для\nolinebreak[2] кожного\nolinebreak[3] $n$ від\nolinebreak[3] $a$ до~$b$ рахувати суму квадратів цифр і перевіряти виконання чи не~виконання <<рівняння>>) надто довгий, аж до $10^{18}$ ітерацій (час роботи --- багато років). 
Тому, перебір треба суттєво оптимізувати. Помітимо такі факти:

\begin{enumerate}
\item
Щоб виконалася рівність $k\times{}f(n)=n$, число\nolinebreak[3] $n$ мусить бути кратним~$k$, тож можна зразу перебирати лише ті ч\'{и}сла від\nolinebreak[3] $a$ до~$b$, які кратні~$k$
(у~цієї ідеї є дещо частково спільне з ідеями зі стор.~\pageref{note:not-check-but-generate-squares} та~\pageref{fig:check-or-gen-only-needed}).

\item
На всьому проміжку до~$10^{18}$ найбільшу суму квадратів цифр має \raisebox{0pt}[1ex][\ifAfour 0ex\else 2ex\fi]{$\underbrace{99\dots9}_{18\textnormal{\footnotesize{ штук}}}$}, тому для всіх~$n$ виконується ${f(n)}\dib{{\<}}{18{\times}9^2}\dib{{=}}1458$.
\end{enumerate}

Тобто, перебір можна почати з найменшого~$n$, одночасно кратного~$k$ і більшого або рівного~$a$, і продовжувати, збільшуючи щоразу на~$k$, доки не виявиться більшим $\min(b,\dib{{}}{1548{\times}k})$ (у~програмі, мабуть, зручніше писати ``\texttt{while (n<=b) and (n<=18*81*a)}''. Очевидно, такий цикл повторюватиметься ні\'{я}к\nolinebreak[2] не\nolinebreak[3] більше 1548\nolinebreak[3] разів, що для комп'ютера зовсім мало. Лишається тільки реалізувати це акуратно, щоб не~було проблем ні з переповненнями типу \verb"int64" (\verb"long long"), ні з похибками (якщо використовувати для проміжних обчислень типи з рухомою комою). Наприклад, \IdeOne{PCj7qR}.