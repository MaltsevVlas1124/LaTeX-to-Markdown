\Tutorial	Задачу в принципі можна розв'язувати по-різному, в тому числі й з використанням циклів, щоб перебирати можливі номер під'їзду й номер поверху (при ${N\,{\<}\,999}$ це вкладеться в обмеження часу). Але\nolinebreak[3] пряма формула природніша, і, мабуть, простіша, тож зосередимось на~ній.

Для мов програмування, де є заокруглення вгору (\verb"ceil", \verb"Ceiling", тощо), можна використати його (разом з діленням у типі з рухомою комою). Якби був лише один під'їзд, то можна було б казати, що на \mbox{1-му} поверсі розміщено квартири з \textnumero$\,$1 по\nolinebreak[3] \textnumero$\,k$, на \mbox{2-му}\nolinebreak[3] --- з \textnumero$\,{(k\,{+}\,1)}$ по\nolinebreak[3] \textnumero$\,{(2\,{\cdot}\,k)}$, тощо; отже, для квартир з \mbox{1-го} поверху $0\dib{{<}}n/s\dib{{\<}}1$; з\nolinebreak[3] \mbox{2-го}, $1\dib{{<}}n/s\dib{{\<}}2$; і~т.~д. Звідси, номер поверху можна \emph{було~б} виражати як \verb"(int)(ceil(((double)n)/k))"\nolinebreak[2] (\mbox{C/C++}; частину дужок можна і прибрати; забезпечити, що ділення робиться в типі \texttt{double}, можна й іншими засобами, але якось це зробити треба), чи \verb"ceil(N/k)"\nolinebreak[3] (Python3), тощо. 
Оскільки під'їзд не~завжди один, в~точності ця формула малокорисна, але потрібні можна побудувати аналогічно. Скажімо, з того, що \mbox{1-й}\nolinebreak[2] під'їзд містить квартири від 1 до\nolinebreak[2] ${s\,{\cdot}\,k}$ (включно), \mbox{2-й}\nolinebreak[3] --- від ${s\,{\cdot}\,k\,\,{+}\,1}$ до\nolinebreak[2] ${2\,{\cdot}\,s\,{\cdot}\,k}$, і~т.~д., слідує, що визначити номер під'їзду можна виразом \verb"(int)(ceil(((double)N)/(s*k)))"\nolinebreak[2] \mbox{(C/C++)},\hspace{0pt plus 0.25em} чи\hspace{0pt plus 0.25em} \verb"ceil(N/(s*k))"\nolinebreak[3] \mbox{(Python3)}, тощо. Якщо номер під'їзду вже пораховано і присвоєно у змінну (наприклад,~\texttt{p}), можна обчислити <<номер квартири у межах під'їзду>> (в\nolinebreak[3] тих самих межах від 1 до\nolinebreak[2] ${s\,{\cdot}\,k}$ включно) як \verb"n"$\,$\verb"-"$\,$\verb"s*k*p"; позначимо цю величину як~\verb"n_p", після чого номер поверху можна обчислити згідно раніше розглянутих міркувань, як \verb"(int)(ceil(((double)n_p)/k))"\nolinebreak[2] \mbox{(C/C++)},\hspace{0pt plus 0.25em} чи\hspace{0pt plus 0.25em} \verb"ceil(n_p/k)"\nolinebreak[3] \mbox{(Python3)}, тощо.

А~що робити, якщо писати на~Паскалі, де нема заокруглення вгору? По-перше, якщо доступний PascalABC, там функція \texttt{Ceil}~\emph{є}; головний недолік PascalABC (що він помітно повільніший за Free\nolinebreak[3] Pascal) у цій задачі абсолютно\nolinebreak[2] не\nolinebreak[3] важливий. По-друге, ніщо\nolinebreak[2] не\nolinebreak[3] заважає переписати те саме, реалізувавши заокруглення вгору самому. Є~щонайменше два способи виразити $\texttt{ceil}(\frac{a}{b})$:\linebreak[2] (А)~\texttt{res:=\nolinebreak[2]a\nolinebreak[3] div~b;\linebreak[2] if\nolinebreak[3] a\nolinebreak[3] mod\nolinebreak[3] b\nolinebreak[2] {<}{>}\nolinebreak[3] 0 then inc(res);}\linebreak[2] (Б)~\texttt{\mbox{(a+b-1)}\nolinebreak[3] div~b}.

\phantomsection\label{text:about-good-formulae-for-0-based-numbering}%
Варто % також 
відзначити: %, що 
\emph{якби нумерація квартир, поверхів і під'їздів була не~з~1, а\nolinebreak[2] з~0, всі формули були~б % помітно 
простіші}. А~с\'{а}ме: 
номер під'їзду виражався\nolinebreak[3] б як 
\verb"N/(s*k)" (С-подібними мовами) чи 
\verb"N//(s*k)"\nolinebreak[2] (Python3) чи 
\verb"N div (s*k)"\nolinebreak[3] (Pascal);
номер поверху виражався\nolinebreak[3] б як 
\verb"(N/k)%s" (С-подібними мовами) чи 
\verb"(N//k)%s"\nolinebreak[2] (Python3) чи 
\verb"(N div k) mod s"\nolinebreak[3] (Pascal).
Власне, ці формули настільки простіші, що може мати смисл навіть перетворити прочитане~\texttt{N} (зменшивши\nolinebreak[2] на~1), провести обчислення за цими формулами, й перетворити кожен з отриманих результатів, збільшивши\nolinebreak[2] на~1.
(Само собою, перетворенням підлягають лише \emph{номери} квартири, поверху й під'їзду, ні\nolinebreak[2] в\nolinebreak[2] якому\nolinebreak[2] разі не\nolinebreak[3] \emph{кількості} $s$~та~$k$.)
А~ще\nolinebreak[2] це\nolinebreak[3] пояснює, чому, хоча людям нумерувати з~0 незручно, більшість сучасних мов програмування мають безальтернативну нумерацію масивів\nolinebreak[2] з~0: таке спрощення перерахунків з'являється не~лише в цій задачі, а й у багатьох %віддалено 
схожих (зокрема, при перетворенні індексів багатовимірного масиву в адресу в пам'яті та зворотньо).
