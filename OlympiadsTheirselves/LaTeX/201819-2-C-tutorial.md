### Чому очевидний підхід набирає так мало балів?
Справді обчислювати сам факторіал і шукати його останню ненульову цифру — формально правильно, але набирає дуже мало балів. Факторіал дуже швидко зростає: ~8! = 40\,320~ вже не поміщається у 16-бітовий знаковий цілий тип, ~13! = 6\,227\,020\,800~ — у 32-бітовий, ~21! = 51\,090\,942\,171\,709\,440\,000~ — у 64-бітовий. Так що для мов програмування, в яких найбільшим цілочисельним типом є 64-бітовий, цей підхід правильний лише для ~N < 20~.

Межу ~N < 20~ можна збільшити до ~N < 23~, якщо щоразу, коли додається нуль наприкінці, тут же відкидати його: ~1 \xrightarrow{\times 2} 2 \xrightarrow{\times 3} 6 \xrightarrow{\times 4} 24 \xrightarrow[\div 10]{\times 5} 12 \xrightarrow{\times 6} 72 \xrightarrow{\times 7} 504 \xrightarrow{\times 8} 4032 \xrightarrow{\times 9} 36288 \xrightarrow[\div 10]{\times 10} 36288 \xrightarrow{\times 11} \dots~

Деякі з дозволених на олімпіаді мов програмування мають вбудовану довгу арифметику, тобто вміють працювати зі значно більшими цілими числами: Python — просто; Java — через бібліотечний тип `BigInteger` . (C# теж має тип `BigInteger`, але там усе сумніше, бо засоби, якими `BigInteger` підключається на локальному Windows-комп'ютері, не працюють на Linux-сервері ejudge, і авторам збірника невідомо ні як їх підключити там, ні, навіть, чи можливо це взагалі.) Використання довгої арифметики (байдуже, готової чи написаної власноруч) дозволяє дещо розширити діапазон ~N~, але недостатньо: з нею повинні проходити не лише всі тести з ~N < 23~, а й усі блоки тестів з ~N < 555~. А подальші блоки повинні не проходити: наприклад, 50000! має понад 200 тис. десяткових цифр, так що обчислення не мають шансів поміститися в обмеження за часом.

### То що ж робити?
Раз питають *лише останню* ненульову цифру, *нема потреби* обчислювати та зберігати *всі* цифри факторіалів. Але це й *не* класична «модульна арифметика» (в якій досить зберігати лише останню цифру), бо питають *останню ненульову*, кількість нулів наприкінці ~N!~ зі зростанням ~N~ час від часу збільшується, й потрібний розряд час від часу зсувається:
при ~1 < N < 4~ це розряд одиниць (остання цифра),
при ~5 < N < 9~ — розряд десятків (передостання цифра), тощо.

Спробуємо з'ясувати, коли скільки нулів додається наприкінці факторіалу. Важливо, що розглядаємо саме десяткову систему числення (~10 = 2^1 \cdot 5^1~) і саме ~N! = 1 \times 2 \times \dots \times N~. Яке б не було число вигляду ~5^a \times b~, число ~2^a \times b~ (при тих самих додатних ~a~, ~b~) існує і менше ~5^a \times b~. Так що, при послідовному домноженні ~(1 \times 2 \times \dots \times (N-1)) \times N~, на кожну п'ятірку, скільки б їх не було в розкладенні ~N~, «вже чекає» відповідна кількість двійок, наявних у розкладенні ~(N-1)!~ і ще не використаних іншими п'ятірками. Так що кожне число, яке можна подати як ~5^a \times b~ (де ~b~ не кратне 5) додає наприкінці факторіала рівно ~a~ нулів.

### Спосіб №1 отримати повні бали (крім Python).
Оскільки ~5^9 = 1\,953\,125 < 2\,018\,019 < 9\,765\,625 = 5^{10}~, за одне домноження з'являтиметься щонайбільше дев'ять нулів.
І ніщо не заважає поєднати такі ідеї: (1) відкидати нулі наприкінці, як тільки вони з'являються; (2) зберігати (у 64-бітовій змінній) останні 10–12 десяткових цифр. Якось так:
~1 \xrightarrow{\times 2} 2 \xrightarrow{\times 3} 6 \xrightarrow{\times 4} 24 \xrightarrow[\div 10]{\times 5} 12 \xrightarrow{\times 6} 72 \xrightarrow{\times 7} 504 \xrightarrow{\times 8} 4032 \xrightarrow{\times 9} 36288 \xrightarrow[\div 10]{\times 10} 36288 \xrightarrow{\times 11} 399168 \xrightarrow{\times 12} 4790016 \xrightarrow{\times 13} 62270208 \xrightarrow{\times 14} 871782912 \xrightarrow[\div 10]{\times 15} 1307674368 \xrightarrow[\bmod 10^{10}]{\times 16} 922789888 \xrightarrow[\bmod 10^{10}]{\times 17} 5687428096 \xrightarrow[\bmod 10^{10}]{\times 18} 2373705728 \xrightarrow[\bmod 10^{10}]{\times 19} 5100408832 \xrightarrow[\div 10, \bmod 10^{10}]{\times 20} 200817664 \xrightarrow{\times 21} 4217170944 \xrightarrow[\bmod 10^{10}]{\times 22} 2777760768 \xrightarrow[\bmod 10^{10}]{\times 23} 3888497664 \xrightarrow[\bmod 10^{10}]{\times 24} 3323943936 \xrightarrow[\div 100]{\times 25} 830985984 \xrightarrow[\bmod 10^{10}]{\times 26} 1605635584 \xrightarrow[\bmod 10^{10}]{\times 27} \dots~
Для ~N < 5^{10}~, 10–12 цифр водночас і досить багато, щоб не втратити зразу всі ненульові цифри, і досить мало, щоб при черговому домноженні ніколи не виникало переповнення 64-бітового типу.

### Спосіб №2 отримати повні бали (крім Python).
Вже відзначено, що класична модульна арифметика (зберігати лише останню цифру) незастосовна, бо питають останню *ненульову*, й потрібний розряд час від часу зсувається. Але можна помітити, що раз кількість нулів наприкінці визначається кількістю п'ятірок, то, прибравши з ~N!~ відповідну кількість п'ятірок і таку саму кількість двійок, отримаємо якраз факторіал крім нулів наприкінці; для цього факторіала крім нулів наприкінці *можна* зберігати й обчислювати саму лише останню цифру.

Конкретніше, будемо при обчисленні ~1 \times 2 \times \dots \times i \times \dots~ «виймати» з кожного числа всі множники 2 та 5, і рахувати окремо останню цифру добутку *всього, крім* «вийнятих» двійок та п'ятірок, окремо різницю кількостей «вийнятих» (на скільки двійок більше, ніж п'ятірок).
Нехай ~d~ — остання цифра добутку нескорочених частин, а ~k~ — поточна різниця кількостей «вийнятих» двійок і п'ятірок (кількість двійок мінус кількість п'ятірок).
Початковий стан: ~d = 1~, ~k = 0~.
Розглянемо кроки множення:

1.  **Було:** ~d=1, k=0~. **Множимо на:** ~i=2~ (розклад ~2 = 2^1 \cdot 5^0 \cdot 1~).
    *   *Коментар:* двійок стає на одну більше.
    *   **Стає:** ~d=1, k=1~.
2.  **Було:** ~d=1, k=1~. **Множимо на:** ~i=3~ (розклад ~3 = 2^0 \cdot 5^0 \cdot 3~).
    *   *Коментар:* кількості двійок та п'ятірок незмінні, добуток решти домножується на 3.
    *   **Стає:** ~d=3, k=1~.
3.  **Було:** ~d=3, k=1~. **Множимо на:** ~i=4~ (розклад ~4 = 2^2 \cdot 5^0 \cdot 1~).
    *   *Коментар:* двійок стає на дві більше.
    *   **Стає:** ~d=3, k=3~.
4.  **Було:** ~d=3, k=3~. **Множимо на:** ~i=5~ (розклад ~5 = 2^0 \cdot 5^1 \cdot 1~).
    *   *Коментар:* «зайвих» двійок стає на одну менше, бо одна двійка «зв'язується» п'ятіркою.
    *   **Стає:** ~d=3, k=2~.
5.  **Було:** ~d=3, k=2~. **Множимо на:** ~i=6~ (розклад ~6 = 2^1 \cdot 5^0 \cdot 3~).
    *   *Коментар:* і двійок стає на одну більше, і добуток решти домножується на 3.
    *   **Стає:** ~d=9, k=3~.
6.  **Було:** ~d=9, k=3~. **Множимо на:** ~i=7~ (розклад ~7 = 2^1 \cdot 5^0 \cdot 7~).
    *   *Коментар:* кількості двійок та п'ятірок незмінні, добуток решти домножується на 7, зберігаємо з 63 лише останню цифру 3.
    *   **Стає:** ~d=3, k=3~.
7.  **Було:** ~d=3, k=3~. **Множимо на:** ~i=8~ (розклад ~8 = 2^3 \cdot 5^0 \cdot 1~).
    *   *Коментар:* двійок стає на три більше.
    *   **Стає:** ~d=3, k=6~.
8.  **Було:** ~d=3, k=6~. **Множимо на:** ~i=9~ (розклад ~9 = 2^0 \cdot 5^0 \cdot 9~).
    *   **Стає:** ~d=7, k=6~.
9.  **Було:** ~d=7, k=6~. **Множимо на:** ~i=10~ (розклад ~10 = 2^1 \cdot 5^1 \cdot 1~).
    *   *Коментар:* додаються одна двійка й одна п'ятірка, *різниця* кількостей незмінна.
    *   **Стає:** ~d=7, k=6~.
10. **Було:** ~d=7, k=6~. **Множимо на:** ~i=11~ (розклад ~11 = 2^0 \cdot 5^0 \cdot 11~).
    *   **Стає:** ~d=7, k=6~. (Примітка: добуток решти (7) домножується на 11, (7*11=77), остання цифра 7)
11. **Було:** ~d=7, k=6~. **Множимо на:** ~i=12~ (розклад ~12 = 2^2 \cdot 5^0 \cdot 3~).
    *   **Стає:** ~d=1, k=8~. (Примітка: (7*3=21), остання цифра 1)
12. **Було:** ~d=1, k=8~. **Множимо на:** ~i=13~ (розклад ~13 = 2^0 \cdot 5^0 \cdot 13~).
    *   **Стає:** ~d=3, k=8~. (Примітка: (1*13=13), остання цифра 3)
13. **Було:** ~d=3, k=8~. **Множимо на:** ~i=14~ (розклад ~14 = 2^1 \cdot 5^0 \cdot 7~).
    *   **Стає:** ~d=1, k=9~. (Примітка: (3*7=21), остання цифра 1)
14. **Було:** ~d=1, k=9~. **Множимо на:** ~i=15~ (розклад ~15 = 2^0 \cdot 5^1 \cdot 3~).
    *   *Коментар:* «зайвих» двійок стає на одну менше, бо одна двійка «зв'язується» п'ятіркою; крім того, добуток решти домножується на 3.
    *   **Стає:** ~d=3, k=8~. (Примітка: (1*3=3), остання цифра 3)

І так далі.
Дорахувавши до множника ~N~ (включно), знаємо останню цифру «~N!~ без двійок та п'ятірок» (позначимо як ~d~) та кількість «вільних» (не «зв'язаних» п'ятірками) двійок (позначимо як ~k~). Остаточна відповідь може бути виражена як
~$(d \cdot 2^k) \bmod 10 = (d \cdot (2^k \bmod 10)) \bmod 10$~. Враховуючи, що
~2^0 = 1~,
~2^1 = 2~,
~2^2 = 4~,
~2^3 = 8~,
~2^4 = 16~,
~2^5 = 32~,
~2^6 = 64~,
~2^7 = 128~,
~2^8 = 256~, \dots,
тобто при ~k > 0~ останні цифри циклічно повторюються,
велике ~k~ можна замінити на ~ (k \bmod 4) + 4~,
що дає можливість обчислювати ~2^k \bmod 10~ за ~$\Theta(1)$~.
Втім, це мало на що впливає, бо основний процес домножень (із «вийманням» з кожного числа двійок та п'ятірок) значно довший.

### Який з цих способів кращий?
Важко сказати. Вони обидва мають складність ~$\Theta(N)$~. (Може здатися, ніби для другого є ще внутрішні цикли «викидання» двійок і п'ятірок, які дають додатковий множник ~$\log N$~; але це не так. Наприклад, сумарну кількість ітерацій, які шукають двійки, можна виразити як
~$N \mathrm{div} 2 + N \mathrm{div} 2^2 + \dots + N \mathrm{div} 2^k$~,
де ~$k = \lfloor\log_2 N\rfloor$~; див. відповідну аргументацію. Формула суми геометричної прогресії каже, що ця сума менша ~N~.)
При вказаних обмеженнях, обидва ці способи гарантовано проходять усі тести (всіма доступними на олімпіаді мовами програмування, *крім Python*; див. наступний абзац). Теоретичний недолік першого способу — якби дозволялися значення ~N > 5^{11} \approx \text{48,8 млн}~, то 64-бітового типу вже було б недостатньо, щоб задовольнити обидві вимоги «не втратити зразу всі ненульові цифри» та «не утворювати переповнень»; другому ж способу цілком достатньо як 64-бітового, так і навіть 32-бітового типу аж до ~N \approx \frac{2^{31}}{9} \approx \text{238 млн}~ (але при ~N \approx 10^8~ обчислення вже тривали б десятки секунд).

### Навіщо скривдили Python?
Він сам себе скривдив.
Програмам усіма мовами програмування виділявся однаковий ліміт часу.
Але для розрахунків, вжитих в обох цих способах, Python виявився значно повільнішим не лише за традиційно швидкі мови `g++` та `fpc`, а також і за відносно повільні `java`, `pasabc-linux` та `mcs`. Враховуючи цю об'єктивну і значну різницю швидкодії, перед туром було прийняте свідоме рішення змиритися з тим, що реалізації одного алгоритму різними мовами набирають різні бали. З точки зору правил та традицій Всеукраїнської олімпіади з інформатики, це погано, але в такого роду виключних випадках допускається. До того ж, у цій самій задачі Python дозволяв отримати бали за тести вигляду ~25 < N < 555~, пишучи «лобовий» розв'язок і взагалі не замислюючись над тим, що така програма використовує довгу арифметику. Учасники, що вміють писати лише на Pascal чи C++, такої можливості не мали, і їм це ніяк не компенсувалося. Тож Python виграє в одному, програє в іншому, й навряд чи було б справедливішим надавати йому додаткові переваги, збільшуючи ліміт часу. Тим паче, що існує ще наступний спосіб.

### Спосіб №3 отримати повні бали (включно з Python).
Обмеження ~N < 2\,018\,019~ підбиралося під те, щоб переважною більшістю мов працювали й набирали повний бал способи 1–2.
Але задачу *можна* розв'язати ще значно ефективніше, якщо правильно модифікувати початий у способі №2 підхід «двійки компенсують п'ятірки, для решти рахуємо останню цифру».
Вважаємо гарантованим ~N > 10~, бо для ~N < 10~ можна написати окремий `if`, щоб рахувати «в лоб».
Виділимо окремо множники, кратні 5, окремо решту, причому решту розіб'ємо на групи згідно десятків.
Наприклад, для 37! буде так: ~{(1 \times 2 \times 3 \times 4 \times 6 \times 7 \times 8 \times 9)} \times (5 \times 10) \times {(11 \times 12 \times 13 \times 14 \times 16 \times 17 \times 18 \times 19)} \times (15 \times 20) \times {(21 \times 22 \times 23 \times 24 \times 26 \times 27 \times 28 \times 29)} \times (25 \times 30) \times {(31 \times 32 \times 33 \times 34 \times 36 \times 37)} \times (35)~.
Добуток ~(5 \times 10) \times (15 \times 20) \times (25 \times 30) \times (35)~ можна подати як ~((5 \cdot 1) \times (5 \cdot 2)) \times ((5 \cdot 3) \times (5 \cdot 4)) \times ((5 \cdot 5) \times (5 \cdot 6)) \times (5 \cdot 7) = 5^7 \times 7!~.
(Важливо, що з кожного числа, кратного 5, виділяється рівно одна п'ятірка, навіть якщо, як з 25, їх можна було б виділити більше.)
Так можна робити й при інших ~N~, отримуючи ~5^{N \mathrm{div} 5} \times (N \mathrm{div} 5)!~. Тобто, з початкової задачі для ~N!~ можна виділити таку саму задачу для ~(N \mathrm{div} 5)!~, і при цьому решта множників поділені на більш-менш зручні групи по 8 з кожного десятку (в останній групі, й лише у ній, може бути менше).
Тож будемо окремо заново розв'язувати всю задачу для ~(N \mathrm{div} 5)!~, і окремо компенсувати п'ятірки, зібрані в ~5^{N \mathrm{div} 5}~, двійками з решти добутків.

Тобто, ~(N \mathrm{div} 5)~ двійок треба «вийняти» з тих решти добутків.
І міркувати «щоб вийняти множник з добутку, поділимо цей добуток на цей множник» тут не можна, бо в модульній арифметиці це часто не так.
Наприклад, ~26 \bmod 10 = 6 = 56 \bmod 10~, тобто з точки зору остач за модулем 10 числа 26 та 56 однаковісінькі, але ~{\tfrac{26}{2} \bmod 10} = {13 \bmod 10} = 3 \neq 8 = {28 \bmod 10} = {\tfrac{56}{2} \bmod 10}~).

Спробуємо компенсувати
дві п'ятірки з ~(5 \times 10)~ двома двійками, «вийнятими» з ~{(1 \times 2 \times 3 \times 4} \times {6 \times 7 \times 8 \times 9)}~,
дві п'ятірки з ~(15 \times 20)~ двома двійками з ~{(11 \times 12 \times 13 \times 14} \times {16 \times 17 \times 18 \times 19)}~,
тощо.
До того, що остання група може бути неповна, повернемося пізніше. Тим, що в кожних таких 8-множникових дужках можна знайти більше, ніж дві, двійки, знехтуємо: їх більше, але «вийматимемо» дві.

Візьмемо число, що закінчується цифрою 2, та число, що закінчується цифрою 4, й «виймемо» з кожного по одній двійці, поділивши кожне окремо на 2 (ділимо самі числа, не остачі). Можуть бути рівно два випадки: або ці числа являють собою ~20k + 2~ та ~20k + 4~, або ~20k + 12~ та ~20k + 14~;
у першому випадку після ділень виходить ~10k + 1~ та ~10k + 2~,
у другому ~10k + 6~ та ~10k + 7~.
Оскільки в межах цих 8-множникових дужок більше не треба ділень, можна вертатися до модульної арифметики, відкидати ~10k~ і казати, що ~1 \times 2 = 2~ та ~6 \times 7 = 42~ закінчуються на однакову цифру 2.
Лишається домножити це 2 на останні цифри решти шести множників у дужках (1, 3, 6, 7, 8, 9), і отримати, що остання цифра добутку (після «виймання» двох двійок) дорівнює
~ (2 \cdot 1 \cdot 3 \cdot 6 \cdot 7 \cdot 8 \cdot 9) \bmod 10 = 4~.
Остання цифра загального добутку всіх ~N \mathrm{div} 10~ штук таких дужок
рівна ~4^{N \mathrm{div} 10} \bmod 10~.
Оскільки
~4^1 = 4~,
~4^2 = 16~,
~4^3 = 64~,
~4^4 = 256~, \dots,
а розглядаємо випадок ~N > 10~, тобто ~ (N \mathrm{div} 10) > 1~,
значення ~4^{N \mathrm{div} 10} \bmod 10~ можна знайти якось у стилі `if ((N div 10) mod 2) = 1 then a:=4 else a:=6`.

Повернемось до врахування того, що при ~N \bmod 10 \neq 0~ існує ще остання дужка, яка рахується не за тими правилами, що решта дужок. Якщо ~1 < N \bmod 10 < 4~, то цій дужці не треба компенсовувати ніяку п'ятірку, можна просто перемножити в модульній арифметиці останні цифри; інакше кажучи, ~ (N \bmod 10)! \bmod 10~. Якщо ж ~5 < N \bmod 10 < 9~, то треба компенсовувати рівно одну п'ятірку. (Навіть якщо число останнього неповного десятку, що закінчується на 5, кратне деякому ~5^k~ при більшому ~k~, то всі п'ятірки, крім однієї, перейшли у ~(N \mathrm{div} 5)!~.) Поділимо на 2 число, що закінчується цифрою 2; можливі рівно два випадки: або воно вигляду ~20k + 2~, або ~20k + 12~; у першому отримуємо ~10k + 1~, у другому ~10k + 6~; більше ділень не треба, можна вертатися до модульної арифметики. Точно треба домножити на 3 та 4 (бо розглядаємо випадок ~5 < N \bmod 10 < 9~); отримуємо
або ~ (1 \times 3 \times 4) \bmod 10 = 12 \bmod 10 = 2~,
або ~ (6 \times 3 \times 4) \bmod 10 = 72 \bmod 10 = 2~,
тобто в обох випадках 2. Множити на 5 не треба й не можна, ця п'ятірка вже врахована іншими засобами.
Лишається тільки домножити в модульній арифметиці на 6, 7, \dots, ~N \bmod 10~ (зокрема, при ~N \bmod 10 = 5~, не домножувати ні на що).

Дії попереднього абзацу насправді рівносильні таким: «порахувати „в лоб“ ~ (N \bmod 10)!~; якщо кратний 10, поділити на 10; взяти останню цифру». Це навіть простіше писати. Але неясно, як строго доводити правильність цього, не спираючись на попередній абзац.

Само собою, треба помножити (в модульній арифметиці) результат (поза)минулого абзаца на раніше отриманий (рівний або 4, або 6) результат ~4^{N \mathrm{div} 10} \bmod 10~, а також домножити (в модульній арифметиці) цей добуток на ~ (N \mathrm{div} 5)! \bmod 10~, розв'язавши всю задачу заново з аргументом ~N \mathrm{div} 5~ замість ~N~. Це повторюватиметься приблизно ~$\log_5 N$~ разів. Що й задає асимптотичну оцінку всього розв'язку ~$\Theta(\log N)$~, бо все інше виконується за ~$\Theta(1)$~ (щось `` `if` ``-ом, щось циклом, але з дуже малою кількістю ітерацій). Так що задачу в принципі можна було давати і для значно більших ~N~. Втім, вона і з обмеженням ~N < 2\,018\,019~ виявилася дещо заскладною для переважної більшості учасників.