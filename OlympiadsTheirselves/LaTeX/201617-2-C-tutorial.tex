\Tutorial	
\MyParagraph{Знаходження 1-ї відповіді.}
З\nolinebreak[3] <<при сповзанні кубики ніколи\nolinebreak[2] не\nolinebreak[3] летять, перекидаючись>> \emph{випливає}, що вони лише зміщуються на правіші позиції, тобто ніякий кубик не\nolinebreak[3] міняє своєї висоти. Кубикам, що лежать на\nolinebreak[3] дні, сповзати нема куди (з\nolinebreak[3] ${1\,{\<}\,a_j}$ слідує, що увесь нижній ряд зайнятий). Будь-який інший кубик на\nolinebreak[3] початку лежав на\nolinebreak[1] нижчому, а\nolinebreak[2] не\nolinebreak[2] висів у\nolinebreak[2] повітрі; от\nolinebreak[2] і\nolinebreak[1] при\nolinebreak[2] нахилі він або сповзає разом із нижчим, на\nolinebreak[2] якому лежить, або, якщо той нижчий впирається у правого сусіда, а\nolinebreak[3] сам поточний\nolinebreak[3] ні, то поточний зсувається праворуч, на нового нижчого, теж не~змінюючи своєї висоти. (Ситуація, що поточний впирається у правого сусіда, а\nolinebreak[3] нижчий\nolinebreak[3] ні, неможлива, бо для цього треба, щоб кубик праворуч до того вже висів у\nolinebreak[2] повітрі, що неможливо.)

Звідси, для простого часткового випадку, коли стовпчиків лише два і ${a_1\,{>}\,a_2}$ (на\nolinebreak[3] початку \mbox{1-й} стовпчик був вищим за \mbox{2-й}), верхні ${a_1\,{-}\,a_2}$ кубиків сповзають з\nolinebreak[3] \mbox{1-го} на\nolinebreak[3] \mbox{2-й}, після\nolinebreak[2] чого вже \mbox{1-й} стовпчик виявляється нижчим (\emph{тієї~ж} висот\'{и}~$a_2$, якої раніше був\nolinebreak[2] \mbox{2-й}), а\nolinebreak[3] \mbox{2-й} вищим (висот\'{и}~$a_1$). Якщо~ж на\nolinebreak[3] початку ${a_1\,{\<}\,a_2}$, взагалі нічого не~змінюється. В~обох випадках, \emph{перший рядок відповіді являє собою відсортовану послідовність висот зі вхідних даних}.

Якщо стовпчиків не\nolinebreak[3] два, а\nolinebreak[3] більше, то все\nolinebreak[3] одно кубики або не\nolinebreak[3] рухаються відносно дна, або\nolinebreak[3] зсуваються послідовно на наразі сусідній стовпчик (можливо, багатократно, але кожен з цих багатьох разів\nolinebreak[3] --- на\nolinebreak[3] сусідній), і~завжди призводить до того, що в~кожній парі сусідніх стовпчиків вис\'{о}ти чи\nolinebreak[3] то лишаються які були, чи\nolinebreak[3] то обмінюються місцями (більша йде праворуч, менша ліворуч). Так\nolinebreak[3] що всі сповзання разом узяті, хоч і можуть відбуватися в\nolinebreak[3] іншому порядку, ніж сортування, в\nolinebreak[3] результаті дають відсортовану послідовність висот.

Отже, \mbox{1-й} рядок відповіді зручно отримати, не~моделюючи весь процес сповзань, а~застосувавши ефективний алгоритм сортування (див.~далі). 



\MyParagraph{Знаходження 2-ї відповіді.}
Щоб не плутати вже відсортовану (для \mbox{1-ї} відповіді) послідовність висот із початковою, будемо в цьому тексті називати відсортовану послідовність $h_1$, $h_2$,\nolinebreak[3] \dots,\nolinebreak[1] $h_N$ (хоча технічно це той самий масив у різні моменти часу).
Усі рядки з\nolinebreak[3] \textnumero$\,$1 по\nolinebreak[3] \textnumero$\,h_1$ заповнені повністю (бо\nolinebreak[2] $h_1$\nolinebreak[3] --- \emph{мімінальна} з\nolinebreak[3] усіх висот), тобто можна вивести у \mbox{2-й} рядок відповіді $h_1$\nolinebreak[3] штук значень~$N$ (де~$N$\nolinebreak[3] --- загальна кількість стовпчиків). Потім ${h_2\,{-}\,h_1}$ рядків містять ${N\,{-}\,1}$ кубиків, причому це так і\nolinebreak[3] при ${h_2\,{>}\,h_1}$ (тоді у~кожному з рядків від \textnumero$\,{(h_1\,{+}\,1)}$ до \textnumero$\,h_2$ включно після зсувів рівно один крайній лівий стовпчик вільний, а\nolinebreak[3] решта зайняті, бо рівно один крайній лівий стовпчик має строго меншу висоту, а\nolinebreak[3] решта більшу-або-рівну), і\nolinebreak[3] при ${h_2\,{=}\,h_1}$ (тоді у~відповідь не~потрапляє жодне значення\nolinebreak[3] ${N\,{-}\,1}$, і\nolinebreak[3] це теж\nolinebreak[3] правильно, бо тоді на всіх висотах по\nolinebreak[3] $h_1$\nolinebreak[1] включно по\nolinebreak[3] $N$\nolinebreak[2] кубиків, а\nolinebreak[3] починаючи з висот\'{и}\nolinebreak[3] ${h_1\,{+}\,1}$ строго менше ніж ${N\,{-}\,1}$ кубик). Аналогічне міркування можна повторити багатократно й отримати, що далі є рівно\nolinebreak[3] ${h_3\,{-}\,h_2}$ значень ${N\,{-}\,2}$, рівно\nolinebreak[3] ${h_4\,{-}\,h_3}$ значень ${N\,{-}\,3}$,\nolinebreak[3] \dots, рівно\nolinebreak[3] ${h_{N}\,{-}\,h_{N-1}}$ значень~1.


\MyParagraph{Асимптотична складність} визначається, в~основному, використаним сортуванням. Бульбашка, вибір та інші прості методи сортування мають складність $O(N^2)$ і не~мають шансів укластися в~обмеження часу на всіх тестах. Сортування злиттям, сортування Хоара (QuickSort) та пірамідальне сортування мають складність $\Theta(N\log N)$ що при ${N\,{\<}\,123456}$ цілком прийнятно. 
%
% \begin{footnotesize}
%
(Хто не~знає цих алгоритмів\nolinebreak[3] --- знайдіть у~літературі або в~Інтернеті; сортування Хоара, хоч і називається QuickSort, насправді має складність $\Theta(N\log N)$ не~завжди, а~тільки у~більшості випадків, іноді погіршуючись аж\nolinebreak[3] до\nolinebreak[3] $N^2$; ця\nolinebreak[3] задача не~містить спеціальних анти-quick\-\mbox{sort-ів}\-ських тестів, тому с\'{а}ме тут це не~важливо, але для розуміння загальної картини варто це знати.)
%
% \end{footnotesize}


Можна й скористатися бібліотечним сортуванням, якщо таке\nolinebreak[3] є (функція \texttt{sort} бібліотеки \texttt{algorithm} мови~C++, або метод \texttt{Arrays.sort} мови Java, або метод \texttt{sort} пітонівського \texttt{list}-а, тощо), не~розбираючись, як це влаштовано всер\'{е}дині. Так робити не~заборонено. Інша справа, що знання про те, як насправді влаштовані ці підпрограми, можуть знадобитися в якихось інших ситуаціях.

\MyParagraph{Альтернативний розв'язок: асимптотика ${\Theta(N\,{+}\,\max a_j)}$ та отримання \mbox{2-ї} відповіді навіть без \mbox{1-ї}.} 
В цій задачі можна застосувати \emph{сортування підрахунком} (\emph{counting sort}). Його суть така: заводиться масив\nolinebreak[3] \texttt{num}, \emph{індекси} якого відповідають \emph{вис\'{о}там}, а~значення\nolinebreak[3] --- \emph{кількості} стовпчиків відповідної висот\'{и} (технічно\nolinebreak[3] --- усі елементи ініціалізуються нулями, а~при читанні вхідних даних, замість\nolinebreak[2] \texttt{read(a[i])}, робляться дії \texttt{read(a); num[a]:=num[a]+1}). 

\mbox{1-а}\nolinebreak[3] відповідь (саме сортування підрахунком) формується як <<\texttt{num[1]}\nolinebreak[2] штук одиниць, потім \texttt{num[2]}\nolinebreak[2] штук двійок, тощо>> (до\nolinebreak[3] речі, це дещо схоже на формування \mbox{2-го}\nolinebreak[3] рядка відповіді раніше розглянутим способом, так\nolinebreak[2] що знання сортування підрахунком може бути корисним як для того, щоб використати його тут, так і для придумування вищезгаданого знаходження \mbox{2-ї}\nolinebreak[3] відповіді \mbox{1-м}\nolinebreak[3] способом). 

\def\tabbb{\hspace*{1em}}

\myflfigaw{\ifAfour\hspace*{-2mm}\begin{minipage}{18.5em}\else\begin{minipage}{17em}\fi\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}num\_gr\_eq[max\_a\_j]:=num[max\_a\_j];\\
for j:=max\_a\_j-1 downto 1 do\\
\tabbb{}num\_gr\_eq[j]:=num\_gr\_eq[j+1]+num[j];\end{alltt}\end{small}\end{minipage}}
А\nolinebreak[3] \mbox{2-у}\nolinebreak[3] відповідь можна отримати так: сформувати на\nolinebreak[3] основі масиву\nolinebreak[2] \texttt{num} масив\nolinebreak[2] \texttt{num\_gr\_eq}, тобто <<кількість більших-або-рівних>> (наприклад, способом, показаним у\nolinebreak[3] коді праворуч), і просто вивести усі елементи \texttt{num\_gr\_eq} чи\nolinebreak[3] то\nolinebreak[1] до\nolinebreak[3] кінця, чи\nolinebreak[3] то\nolinebreak[1] доки вони ненульов\'{і}.

Легко бачити, що асимптотика такого підходу ${\Theta(N\,{+}\,\max a_j)}$, що формально краще за $\Theta(N\log N)$. Втім, на~практиці різниця між ними невелика й у~значній мірі нівелюється часом читання вхідних даних. Так\nolinebreak[3] що питання більше в~тому, що\nolinebreak[3] зручніше писати. Якщо є зручне готове бібліотечне сортування\nolinebreak[3] --- мабуть, краще використати його і знаходження \mbox{2-ї} відповіді через \mbox{1-у}.
