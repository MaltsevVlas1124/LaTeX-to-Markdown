\Tutorial	Задачу можна розв'язати ручним аналізом випадків, але це сумнівний спосіб, доречний, лише коли нема кращих ідей. За\nolinebreak[2] посиланням \IdeOne{jjq2Pq} можна побачити трохи модифікований варіант програми, яку здав один з\nolinebreak[3] учасників. Він набирає 270\nolinebreak[3] балів з\nolinebreak[3] 300, що з\nolinebreak[3] одного боку немало, але\nolinebreak[2] з\nolinebreak[2] іншого\nolinebreak[3] --- на\nolinebreak[3] аналіз випадків явно пішло багато часу, бали все\nolinebreak[2] одно не\nolinebreak[3] повні, а\nolinebreak[3] шукати помилку в\nolinebreak[3] \emph{такому} нагромадженні\nolinebreak[3] --- невдячна справа.\phantomsection\label{text:about-complicated-code-with-many-ifs} 

Щоб уникнути такої ситуації, краще реалізувати осмислений алгоритм, який обробляє різні вхідні дані більш-менш однотипно.

{

\hyphenpenalty=400

Раз йдеться про\nolinebreak[3] мінімальні (за\nolinebreak[3] кількістю переходів) шляхи, природним є \emph{пошук\nolinebreak[3] ушир} (він\nolinebreak[3] же \emph{пошук у~ширину}, англ.\nolinebreak[3] \emph{breadth first search}, \emph{BFS}). Застосувати\nolinebreak[2] BFS треба до\nolinebreak[3] неорієн\-то\-ваного графа, вершини якого\nolinebreak[3] --- вершини куба зі значенням~1 (по\nolinebreak[3] яким можна проходити), р\'{е}бра\nolinebreak[3] --- ті р\'{е}бра куба, що\nolinebreak[3] поєднують такі вершини.
%
Причому, раз питають не\nolinebreak[3] в\'{і}д\-стань (число), а\nolinebreak[3] шлях (послідовність вершин), потрібен варіант\nolinebreak[2] BFS,\linebreak[1] у\nolinebreak[3] якому запам'ятовують вершини-попередники та роблять відновлення шляху \emph{зворотнім ходом}. Деталі знайдіть у\nolinebreak[3] літературі або Інтернеті.

}

Інший можливий спосіб\nolinebreak[3] --- 
% повний 
перебір (наприклад, рекурсивний) усіх 
можливих 
шляхів, що не\nolinebreak[3] містять повторень вершин. Приклад такого розв'язку\nolinebreak[3] --- \IdeOne{pihZzm}. Детальніше 
% про цей підхід реалізації перебору 
про це 
можна прочитати в\nolinebreak[3] Інтернеті або літературі за назвами \emph{пошук з\nolinebreak[3] поверненнями}, \emph{бектрекінг} (рос.\nolinebreak[3] \emph{поиск с\nolinebreak[3] возвратом}, англ.\nolinebreak[3] \emph{back-tracking}). 
% Якщо говорити про бектрекінг взагалі, то 
Взагалі кажучи,
цим не\nolinebreak[3] дуже складним способом 
% суто 
теоретично можна розв'язати дуже багато задач, але 
% бектрекінг 
він 
% зазвичай 
часто 
% працює надто довго (наприклад, $O(N!)$) і не~вкладається 
працює надто довго, не~вкладаючись
в обмеження часу. А тут вкладається, бо вершин всього~8.

На\nolinebreak[3] жаль, ідея <<писати осмислений алгоритм, щоб обробляти різні вхідні дані однотипно>> мало придатна до заданої рисунком відповідності ребер куба його вершинам. 
% % % Важко сформулювати правилом, між якими вершинами є ребро і між якими нема. 
Важко сформулювати, між якими с\'{а}ме вершинами є р\'{е}бра. 
(Найкраще, що вдалося\nolinebreak[3] --- % заплутане 
\textsl{<<Позначки вершин відрізняються або на~4, або на~1, але крім $d{\leftrightarrow}e$, а~крім названих, є ще $a{\leftrightarrow}d$ і\nolinebreak[3] $e{\leftrightarrow}h$>>}.) Мабуть, легше задати явний перелік (чи\nolinebreak[3] як у\nolinebreak[3] розв'язку з попереднього абзацу, чи вписати у текст програми константний масив\nolinebreak[3] --- матрицю суміжності графа, чи\nolinebreak[2] ще якось). Але це треба ретельно звіряти з умовою, бо успішна побудова шляхів у одній частині графа ніяк не\nolinebreak[3] перевіряє правильність задання ребер у іншій частині. 

\MyParagraph{Прості способи набрати частину балів.}\phantomsection\label{text:log-cube-how-to-get-part-of-points-easily}
Тести цієї задачі такі, що програма, яка, не~вирішуючи задачу по\nolinebreak[3] суті, завжди виводить~``\texttt{NO}'', набирає 90\nolinebreak[3] балів з~300. Можливо, це й несправедливо багато. Але з\nolinebreak[3] умови (та\nolinebreak[2] з\nolinebreak[2] того, що у~2013~р. використовувалося лише потестове оцінювання) очевидно, що така програма мусила хоч\nolinebreak[2] щось та набрати; хто не\nolinebreak[3] міг розв'язати правильно\nolinebreak[3] --- мав\nolinebreak[3] би пошукати якісь такі варіанти.
Трохи чесніший спосіб\nolinebreak[3] --- перевіряти, чи\nolinebreak[3] є вершини кінцями одного ребр\'{а}, і\nolinebreak[3] якщо так, то виводити ці вершини, а\nolinebreak[3] якщо\nolinebreak[3] ні, то\nolinebreak[3] ``\texttt{NO}''. Він набирав 150\nolinebreak[3] балів (рівно половину).