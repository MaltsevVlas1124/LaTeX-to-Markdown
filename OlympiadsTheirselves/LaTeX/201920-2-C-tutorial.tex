\Tutorial
\MyParagraph{Чому в одному турі дві майже однакові задачі~C,~D?}
\emph{Деякі} способи їх розв'язувань, справді, майже однакові. Але <<лобовий>> спосіб набирає далеко\nolinebreak[3] не\nolinebreak[3] всі\nolinebreak[2] бали,\linebreak[2] а\nolinebreak[3] серед ефективніших способів далеко\nolinebreak[3] не\nolinebreak[3] всі однаково придатні до обох задач. 
%%% Зокрем\'{а}, розглянутий далі досить простий 100$\,$\%-й спосіб розв'язання цієї задачі абсолютно непридатний для наступної (втім, деякі з розглянутих у розборі наступної задачі способів більш-менш придатні до цієї).

\MyParagraph{Це що, аж так важливо, чи знає учасник хитрі способи читання вхідних даних?} І~так, і~ні.\linebreak[2] Що~ж зробиш, як олімпіади з інформатики (програмування) вже більше 25~років передбачають розрізнення більш ефективних розв'язків від менш ефективних,\linebreak[2] а\nolinebreak[2] % с\'{а}ме 
в\nolinebreak[2] цих задачах швидкість введення/\nolinebreak[2]виве\-дення істотно впливає на швидкість програми в цілому\mbox{?.\hspace{0.1em}.} Це~не~створено автором задачі навмисно, це сумний об'єктивний факт, який час від часу проявляється на оліміпадах (див. також стор.~\pageref{text:io-streams-versus-scanf-printf},\nolinebreak[3] \mbox{\pageref{sec:omnipresent-numbers}--\pageref{text:omnipresent-numbers-end}}). І\nolinebreak[3] це\nolinebreak[2] точно \emph{не}~є істотною складовою оцінювання: якби хотіли це перевіряти, то інформацію про різні способи читання не~доносили~б різними способами безпосередньо на турі, а\nolinebreak[3] всіляко приховували. І~якраз приховування було~б несправедливим щодо тих учасників, які взагалі-то придумали й реалізували ефективний алгоритм, але програма не~набирає гідний бал виключно том\'{у}, що повільно читає вхідні дані. <<Просто зменшити вхідні дані та/або збільшити обмеження часу>>\nolinebreak[3] --- теж так\nolinebreak[3] собі пропозиція, бо тоді почали б надто легко проходити не~досить ефективні алгоритми.

\MyParagraph{Як досить легко набрати частину балів? Чому так набирається лише частина балів?} Приклади нехитрих <<лобових>> розв'язків можна бачити за посиланнями 
\begin{Huge}
\begin{color}{red}
TODO: add IDEONE links here
\end{color}
\end{Huge}.
Вони повинні проходити блоки \mbox{1--2}, але не~проходити жодного іншого блоку. Адже складність $O(M{\cdot}N{\cdot}T)$ (див., зокрема, стор.~\pageref{text:asymptotic-defs-begin}--\pageref{text:asymptotic-defs-end}) свідчить про крайню сумнівність вкладання виконання у секунду для одночасно максимальних $N$, $M$, $T$ будь-якого з\nolinebreak[2] блоків\nolinebreak[3] \mbox{3--6}. (<<Заперечення>> у стилі \begin{slshape}<<ну\nolinebreak[2] не~будуть же там геть усі прямокутники-запити вигляду ``1~N~1~M'', бо\nolinebreak[2] тоді взагалі всі суми-відповіді будуть однакові>>\end{slshape} нічогісінько не~змінює: наприклад, у\nolinebreak[3] тесті з\nolinebreak[3] блоку~3 дуже навіть може бути, скажімо, 80$\,$\% запитів, де
$1\,{\<}\,i_1\,{\<}\,5$,\hspace{0pt plus 0.5em}
$20\,{\<}\,i_2\,{\<}\,25$,\hspace{0pt plus 0.5em}
$1\,{\<}\,j_1\,{\<}\,200$,\hspace{0pt plus 0.5em}
$1800\,{\<}\,j_2\,{\<}\,2019$,\hspace{0pt plus 0.5em}
і 20$\,$\% % суто 
випадкових;
це не~сильно зменшить час, а~однакових відповідей буде мало.)

\myflfigaw{\ifAfour\begin{minipage}{10.5em}\else\begin{minipage}{9.5em}\fi\begin{small}\renewcommand{\baselinestretch}{0.875}\begin{alltt}sum := 0;\\
for i:=i1 to i2 do\\
\tabbb{}for j:=j1 to j2 do\\
\tabbb\tabbb{}sum:=sum+a[i][j];\end{alltt}\end{small}\end{minipage}}
\MyParagraph{То що, рахувати суми вкладеними циклами, як праворуч\nolinebreak[3] --- погано?}
Якби рахувати треба було один раз (чи~двічі, чи навіть 10~разів), це був~би найдоцільніший (бо\nolinebreak[3] найприродніший) спосіб. Але ж просять порахувати $T$\nolinebreak[3] разів для (мабуть, різних) прямо\-кут\-ників-запитів. Найзагальніша ідея обох задач\nolinebreak[3] C,~D\nolinebreak[3] --- придумати, що\nolinebreak[3] б такого зробити з двовимірним масивом (одним! незмінним!), щоб, хай навіть витративши (\emph{єдинократно!}) якісь додаткові зусилля/\nolinebreak[2]час/\nolinebreak[2]пам'\-ять (це,\nolinebreak[2] до\nolinebreak[3] речі, називають \emph{перед\-оброб\-кою}), надалі могти швидше відповідати на сам\'{і} запити.
%%%, яких буде $T$~штук. 
\begin{itshape}\begin{bfseries}{Як~с\'{а}ме робити}\end{bfseries} передобробку і \begin{bfseries}що~с\'{а}ме\end{bfseries} вона \begin{bfseries}повинна дати\end{bfseries}\end{itshape}\nolinebreak[3] --- це вже складніше питання; різним варіантам відповіді на нього присвячена решта розбору цієї задачі та майже весь розбір наступної.

\MyParagraph{Префіксні суми для одновимірного випадку.}
Розглянемо аналогічну (але простішу) задачу, де дано \underline{\emph{одно}}\-вимір\-ний масив і треба відповідати на багато запитів \textsl{<<яка сума всіх підряд елементів з \mbox{$i$-го} по \mbox{$k$-й}?>>} (до~речі, така задача вже давно є на \EjudgeCkipoName, як задача~A \href{https://ejudge.ckipo.edu.ua/cgi-bin/register?action=212&contest_id=7&locale_id=2}{змагання~7}). 

\myflfigaw{\mbox{\begin{small}\begin{tabular}{@{}r|rrrrrrrrr@{}}
індекс													& 0 &  1 &  2 &  3 &  4 &  5 &  6 &  7 &  8 \\\hline
початковий масив \texttt{data}			&   &  3 &  1 &  4 &  1 &  5 &  9 &  2 &  6 \\\hline
масив префіксних сум \texttt{sum}		& 0 &  3 &  4 &  8 &  9 & 14 & 23 & 25 & 31 \\
\end{tabular}\end{small}}}
Там варто завести масив, кожен елемент якого має смисл \textsl{<<Яку суму мають усі елементи від початку до поточного?>>}. Чи~починати, як у наведеному прикладі, нумерацію елементів сам\'{о}го масиву з~1, а~масиву сум\nolinebreak[3] з~0\nolinebreak[3] --- питання дискусійне, такі деталі можна робити по-різному, в кожного способу свої 
переваги й вади; можна 
% переваги й недоліки; кінець кінцем, можна 
у~програмі написати якось інакше, але у поясненнях буде с\'{а}ме так.

Маючи такий масив\nolinebreak[2] \texttt{sum}, можна рахувати суму будь-якого проміжку 
\begin{ttfamily}{data[j]$\,$+$\,$}\nolinebreak[2]%
{data[j+1]$\,$+$\,$}\nolinebreak[3]\mbox{\dots$\,$+$\,$}\nolinebreak[2]%
{data[k]}\end{ttfamily} \emph{за~одне віднімання},\linebreak[2] як\nolinebreak[2] \begin{ttfamily}{sum[k]$\,$-$\,$}\nolinebreak[3]{sum[j-1]}\end{ttfamily}, адже з <<загальної>> суми 
\begin{ttfamily}{data[1]$\,$+$\,$}\nolinebreak[2]%
{data[2]$\,$+$\,$}\nolinebreak[3]\mbox{\dots$\,$+$\,$}\nolinebreak[2]%
{data[k]}\end{ttfamily}
якраз приберуть <<непотрібну>> суму 
\begin{ttfamily}{data[1]$\,$+$\,$}\nolinebreak[2]%
{data[2]$\,$+$\,$}\nolinebreak[3]\mbox{\dots$\,$+$\,$}\nolinebreak[2]%
{data[j-1]}\end{ttfamily}.

Що це дає для початкової задачі? 
Навіть якщо реалізувати \emph{лише} цей прийом, тобто порахувати префіксні суми для кожного рядка двовимірного масиву окремо, і відповіді на запити рахувати як <<перебрати рядки прямокутника, й додати в циклі суми, знайдені одним відніманням кожна>>\nolinebreak[3] --- навіть тоді виходить $O(N{\cdot}M\,{+}\,T{\cdot}N)$ дій, що повинно точно проходити блок~3, а~при акуратній реалізації цілком може пройти також блок~5. (Звісно, для цього потрібно правильно рахувати масив префіксних сум, наприклад, якось у стилі \begin{ttfamily}\mbox{sum[i][0]:=0;} \mbox{for j:=1 to M}\nolinebreak[2] do \mbox{sum[i][j]:=}\nolinebreak[2]\mbox{sum[i][j-1]+}\nolinebreak[2]a[i][j]\end{ttfamily},\linebreak[2] ні~в~\'{я}ко\-му\nolinebreak[2] разі\nolinebreak[2] не\nolinebreak[3] запускаючи ще~один цикл для кожного елементу префіксних сум.)

Блок~4 яскраво демонструє, що префіксні суми за рядками й перебір рядків\nolinebreak[3] --- лише часткове покращення, і може підбити до того, щоб рахувати в одній програмі зразу два варіанти префіксних сум: за рядками і за стовпчиками. Що~ж, якщо правильно вибирати, коли яка сума доцільніша, це може ще щось покращити: дозволити одній програмі пройти і~блок~3, і~блок~4; покращити <<запас>> часу при проходженні блоку~5 (але якщо він і~так пройшов, то збільшення запасу ніяк не~підвищує бали за задачу). Але само по собі це ще~не~повинно давати можливість пройти блок~6 і тим розв'язати задачу повністю. 
%
У~поєднанні зі ще якимись оптимізуючими прийомами, це вже можливо; наприклад, можна придумати такий прийом, як \textsl{<<за\nolinebreak[3] розмірами прямокутника поточного запиту, вибрати, який з трьох підходів має бути найшвидшим саме для нього: порахувати за рядками, чи порахувати за стовпчиками, чи (якщо він займає майже увесь основний масив) порахувати як різницю суми всього основного масиву, мінус сума <<рамки>>, що не~потрапляє, а суму <<рамки>>, що не~потрапляє, порахувати через горизонтальні та вертикальні префіксні суми>>}. Або такий прийом, як \textsl{<<порахувати усі ці горизонтальні та вертикальні префіксні суми і~для\nolinebreak[3] кожного рядка/\nolinebreak[2]стовп\-чика окремо, і~для\nolinebreak[3] шматків по 10~рядків/\nolinebreak[2]стовп\-чиків підряд; це дасть можливість рахувати за одне віднімання суму не~одного рядка/\nolinebreak[2]стовп\-чика, а~зразу десяти (щоправда, якщо м\'{е}жі прямокутника-запиту не~потрапили на ці красиві м\'{е}жі шматків по 10~рядків/\nolinebreak[2]стовп\-чиків підряд, то по краям (чи\nolinebreak[3] з\nolinebreak[3] одного краю) треба буде пододавати також суми окремих рядків/\nolinebreak[2]стовп\-чиків)>>}. Або ще якийсь оптимізуючий прийом\nolinebreak[3] --- їх тут може бути чимало різних. Але спосіб, наведений у наступному пункті, і~простіший у~плані технічної роботи, і~переконливіший у~плані теоретичного доведення часу його роботи.

\myflfigaw{\begin{tabular}{@{}r|rrrrr@{$\,\quad\,$}r|rrrrr@{}}
\multicolumn{1}{c}{} &&&&&&
& ${}_0$
& ${}_1$
& ${}_2$
& ${}_3$
& ${}_4$
\\\cline{7-12}
& ${}_1$
& ${}_2$
& ${}_3$
& ${}_4$
&
& 
${}_0$ & 0 & 0 & 0 & 0 & 0 \\\cline{1-5}
{${}_1$}
& 2 & 3 & 4 & 5
&
&
${}_1$ & 0 & 2 & 5 & 9 & 14 \\
{${}_2$}
& 3 & 1 & 4 & 1
&
&
${}_2$ & 0 & 5 & 9 & 17 & 23 \\
{${}_3$}
& 5 & 9 & 2 & 6
&
&
${}_3$ & 0 & 10 & 23 & 33 & 45 \\
\end{tabular}}
\MyParagraph{Рекомендований 100$\,$\%-й спосіб --- двовимірне узагальнення префіксних сум.}
Замість незруч\-но й неефе\-ктив\-но працювати з багатьма окремими одновимірними префіксними сумами, краще здогадатися до такого їх двовимірного узагальнення: будемо для кожного елементу двовимірного масиву тримати суму всіх елементів, розміщених лівіше\&вище за нього (конкретно у тому варіанті, який наведено на рисунку праворуч\nolinebreak[3] --- включаючи рядок\&стовп\-чик сам\'{о}го поточного елемента; наприклад, $\texttt{sum[2][3]}\,{=}17$ виражає суму ${(2\,{+}\,3\,{+}\,4)}\dibbb{{+}}{(3\,{+}\,1\,{+}\,4)}$; але, як і для одновимірного випадку, можуть бути варіанти, де індекси зсунуті якось інакше).

Коли такий масив уже побудований, то взнавати потрібну суму для прямокутника $i_1$~$i_2$~$j_1$~$j_2$ можна виразом 
\begin{ttfamily}%
sum[i2][j2]\nolinebreak\hspace{0.125em plus 0.125em}-\nolinebreak[2]\hspace{0.125em plus 0.125em}%
sum[i2][j1-1]\nolinebreak\hspace{0.125em plus 0.125em}-\nolinebreak[2]\hspace{0.125em plus 0.125em}%
sum[i1-1][j2]\nolinebreak\hspace{0.125em plus 0.125em}+\nolinebreak[2]\hspace{0.125em plus 0.125em}%
sum[i1-1][j1-1]\end{ttfamily}.

\myflfigaw{\hspace*{-1mm}\begin{mfpic}[18]{-0.5}{8}{0}{4.5}
\tlabel[cr](-0.05, 1.375){$i_2$}
\tlabel[cr](-0.05, 2.625){$i_1$}
\tlabel[cr](-0.05, 3.375){$i_1{-}1$}
\tlabel[bc](6.625, 4.05){$j_2$}
\tlabel[bc](3.375, 4.05){$j_1$}
\tlabel[bc](2.5, 4.05){$j_1{-}1$}
%
\fillcolor{gray(0.75)}
\gfill\polygon{(0,4),(0,1),(7,1),(7,4)}
\drawcolor{black}
\hatchcolor{black}
\lhatch\polygon{(0,4),(0,1),(3,1),(3,4)}
\rhatch\polygon{(0,4),(0,3),(7,3),(7,4)}
%
\dotted\lines{(0,0),(0,4)}
\dotted\lines{(1,0),(1,4)}
\dotted\lines{(2,0),(2,4)}
\dotted\lines{(3,0),(3,4)}
\dotted\lines{(4,0),(4,4)}
\dotted\lines{(5,0),(5,4)}
\dotted\lines{(6,0),(6,4)}
\dotted\lines{(7,0),(7,4)}
\dotted\lines{(8,0),(8,4)}
%
\dotted\lines{(0,0),(8,0)}
\dotted\lines{(0,1),(8,1)}
\dotted\lines{(0,2),(8,2)}
\dotted\lines{(0,3),(8,3)}
\dotted\lines{(0,4),(8,4)}
%
\pen{1mm}
\polygon{(3,1),(7,1),(7,3),(3,3)}
\end{mfpic}}
Аргументація цього частково зображена на рисунку: щоб знайти суму області, виділеної рамкою, з суми області, виділеної сірим, віднімемо суму області, виділеної однією штриховкою, та суму області, виділеної іншою штриховкою; область, де штриховки накладаються, один раз додана й двічі віднята, тож, щоб це компенсувати, треба додати її.

Будувати цей масив \texttt{sum} можна за правилом
\begin{ttfamily}%
sum[i][j]\nolinebreak\hspace{0.125em plus 0.125em}=\nolinebreak[2]\hspace{0.125em plus 0.125em}%
sum[i][j-1]\nolinebreak\hspace{0.125em plus 0.125em}+\nolinebreak[2]\hspace{0.125em plus 0.125em}%
sum[i-1][j]\nolinebreak\hspace{0.125em plus 0.125em}-\nolinebreak[2]\hspace{0.125em plus 0.125em}%
sum[i-1][j-1]\nolinebreak\hspace{0.125em plus 0.125em}+\nolinebreak[2]\hspace{0.125em plus 0.125em}%
a[i][j]\end{ttfamily}, яке обґрунтовується майже так само, тільки сіра незаштрихована область має складатися з єдиного елемента.

Тобто, заповнити масив \texttt{sum} можна за $\Theta(1)$ дій на кожен елемент, а відповідати на запити можна за $\Theta(1)$ дій на кожен запит. Читання вхідних даних та виведення результатів мають аналогічні оцінки часу. Таким чином, весь алгоритм має складність ${\Theta(N{\cdot}M+T)}$. (До\nolinebreak[3] речі, якраз поєднання <<час роботи пропорційний розміру вхідних даних>> та <<вхідні дані величезні>> пояснює, чому в цій задачі аж так важливі швидкі введення/\nolinebreak[3]виве\-дення: вони не~<<губляться>> за рештою операцій.)


\MyParagraph{То мені що, заводити масив розмірами 2020$\times$2020, незважаючи на те, що фактично таких тестів не~буде?}
Якщо писати мовою програмування, в~якій розмір масиву задається зарані (під час написання програми, отже, до прочитання вхідних даних)\nolinebreak[3] --- так, тоді це єдиний вихід. Але ліміту пам'яті на це вистачає, із запасом. А~якщо задавати розміри масивів після прочитання вхідних даних, таке питання, зазвичай, взагалі не~виникає: прочитали $N$,~$M$, задали розміри\dots{}; і\nolinebreak[2] в\nolinebreak[3] цій\nolinebreak[2] задачі \underline{\emph{не}}~виникає рідкісної ситуації, коли заміна динамічної пам'яті на статичну дає істотне прискорення.

\MyParagraph{А~без префіксних сум чи їхніх прямокутних узагальнень набрати більше~30$\,$\% балів не~можна?}
Не~те, щоб геть\nolinebreak[2] не~можна; частина способів, описаних у наступній задачі, цілком годяться, щоб пройти у цій задачі, наприклад, блоки\nolinebreak[3] \mbox{1--5}. Є~й~інші способи, геть невеликі модифікації яких повністю вирішують зразу обидві задачі. Але вони складніші за згадані тут. Том\'{у}, автор більш схиляється до того, що, мабуть, легше написати окремо спосіб для цієї задачі, якось оснований на префіксних сумах, і окремо інший спосіб для наступної задачі; але це сильно залежить від того, які с\'{а}ме ідеї вдалося пригадати чи придумати під час туру.

\MyParagraph{А~блоки 1 та 2 взагалі чимсь відрізняються з точки зору розв'язування?} З~точки зору переважної більшості алгоритмів, нічим: майже будь-яка розумно написана програма, що проходить \mbox{1-й}\nolinebreak[3] блок і~не~містить явних обмежень проти \mbox{2-го}\nolinebreak[3] блоку, має проходити також\nolinebreak[3] і\nolinebreak[3] \mbox{2-й}. Але відмінність може проявитися для помилкових реалізацій, які: неправильно читають багатоцифрові ч\'{и}сла; неправильно обробляють ситуацію, коли є лише один стовпчик чи лише один рядок;  намагаються використати аж надто короткий тип даних (тут, зокрема, для когось може виявитися несподіванкою, що у FreePascal тип \texttt{integer} досі 16-бітовий, тому треба використовувати для самих елементів щонайменше \texttt{longint}, для сум \texttt{QWord} чи \texttt{int64}; див.\nolinebreak[3] також стор.~\pageref{text:overflow-example} та стор.~\pageref{text:notes-about-delphi-mode}); якось дуууже вже неефективно читають вхідні дані. Що~ж, ситуації, коли програмі (нехай навіть мовою Python) не~вистачає 2~секунд на тому тесті, на якому найкраща наявна програма мовою~C++ вкладається у 0,001~с (різниця у тисячі разів), все-таки є явною ознакою погано написаної програми\dots