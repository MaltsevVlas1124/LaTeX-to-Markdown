## Пояснення

Само собою, для розуміння цієї задачі варто спочатку зрозуміти задачу «Василько та циркуль--1», бо ця задача є подальшим розвитком тієї.

В будь-якому (від найпростішого до найефективнішого) розв'язку цієї задачі використовуються такі факти та спостереження аналітичної геометрії:
- відстань між точками з координатами ~(x,y)~ та ~(x_i,y_i)~ становить ~$\sqrt{(x-x_i)^2+(y-y_i)^2}$~ (оскільки система координат прямокутна, цю формулу можна отримати як наслідок з теореми Піфагора);
- коли *центр* круга має відстань ~d_i = \sqrt{(x-x_i)^2+(y-y_i)^2}~ від точки ~(x,y)~, з якої як з центра Василько намагається малювати свої кола, то найближча точка цього круга розміщена на відстані ~d_i - r_i~, а найдальша --- на відстані ~d_i + r_i~ (де ~r_i~ --- радіус цього круга; нижня межа ~d_i - r_i~ взята у припущенні, що точка ~(x,y)~ не потрапляє всередину цього кола; якщо потрапляє, величина ~d_i - r_i~ стає від'ємною; взагалі-то відстані від'ємними не бувають, але в рамках цієї задачі це означає, що потрібно за спеціальним розгалуженням виводити відповідь 0 і не рахувати далі по суті, тому можна все-таки рахувати за формулою ~d_i - r_i~, заодно перевіряючи знак).

(Аргументувати, що (при перебуванні ~(x,y)~ ззовні круга) проміжок відстаней між ~(x,y)~ та різними частинами круга справді становить «від ~d_i - r_i~ до ~d_i + r_i~, де ~d_i = \sqrt{(x-x_i)^2+(y-y_i)^2}~», можна, наприклад, так: проведемо пряму, що проходить через ~(x,y)~ та ~(x_i,y_i)~; межі круга радіусом ~r_i~ завжди, в тому числі й на цій прямій, перебувають на відстані ~r_i~ від його центру; так і виходить, що найближча до ~(x,y)~ точка круга розміщена на відстані ~d_i - r_i~ (на ~r_i~ ближче, чим центр), а найдальша на відстані ~d_i + r_i~ (на ~r_i~ далі, чим центр).)

**Очевидний підхід, 60% балів.**
З урахуванням усього досі описаного, досить очевидним є такий, наприклад, розв'язок:
1. ініціалізувати `ans = 0`;
2. перебрати зовнішнім циклом усі можливі кола радіусів ~r~, ~2r~, ~3r~, ... (можна обчислити кількість кіл за формулою, виведеною в задачі «Василько та циркуль--1», чи написати тут `while`, який збільшуватиме радіус на ~r~, доки не відбудеться торкання до чи вихід за хоча б одну зі стінок (ліва, нижня, права, верхня))), і для кожного такого кола
    1. перебрати внутрішнім циклом всі можливі дірки-круги, і для кожного такого круга
        1. перевірити, чи потрапляє радіус кола, яке міг малювати Василько (визначається зовнішнім циклом) у той проміжок відстаней «від ~d_i - r_i~ до ~d_i + r_i~», що відповідає поточній дірці-кругу (визначається внутрішнім циклом).
    Якщо коло (визначається зовнішнім циклом) не потрапило ні в одну дірку-круг (визначається внутрішнім циклом), збільшити `ans` на 1.
3. вивести `ans`

Правильність такого алгоритму досить зрозуміла: Василько міг би намалювати деяке коло --- перевіряємо, чи справді ніщо не заважає; щоб перевірити, порівнюємо з дірками-кругами.

Але біда в тому, що якщо розглянути обмеження нехай навіть не останнього, а передостаннього блоку (~A, B < 10^6~, ~N < 2020~), то зрозуміло, що пройти цей блок шансів нема: при ~A \approx B \approx 10^6~, ~x \approx y \approx \frac{10^6}{2}~, ~r=1~ виходить, що кількість кіл, які міг би намалювати Василько, ~{}\approx 5 \cdot 10^5~, і якщо кожне треба порівнювати з кожною з ~N \approx 2000~ дірок-кругів --- це ~{}\approx 10^9~ досить громіздких порівнянь. (Якби нарахування балів було потестовим, а не блоковим, можна було б сподіватися набрати бали хоча б за частину тестів з такими обмеженнями, якщо грамотно використати `break` для обривання внутрішнього циклу перебору дірок-кругів, як тільки буде знайдено перший пертин поточного кола; але з блоковим нарахуванням балів шанси на успішність таких оптимізацій істотно зменшуються, і для використаного набору тестів `break`, начебто, просто не допомагає.)

**А як набрати більше балів?**
Як завжди: придумавши спосіб розглянути задачу під іншим кутом зору.
Запровадимо «вісь радіусів», де радіусами є радіуси тих кіл, які міг би провести Василько. Можна сказати, що це радіуси, котрі використовуються у полярній системі координат (якщо початок координат полярної системи --- у спільному центрі тих кіл, які намагається проводити Василько)... втім, таку «вісь радіусів» можна запровадити й не пов'язуючи її з полярною системою координат. Головне, що на цій «вісі» відкладаються відстані від центру ~(x,y)~ кіл, які намагається провести Василько. Причому, важливі *лише* відстані (а напрям не важливий); якщо пов'язувати це із полярною системою координат, то будемо розглядати самі лише радіуси, без кутів.

Кожне коло, яке намагається провести Василько, відображається на «вісь радіусів» єдиною точкою, єдина координата якої дорівнює радіусу цього кола. Отже, всі кола, які міг би намалювати Василько, якби стіни були такі самі, але не було дірок-кругів, перетворюються у точки ~r~, ~2r~, ~3r~, ..., ~K \cdot r~ на «вісі радіусів» (тут і далі, ~K~ --- кількість кіл, знайдена, як у задачі «Василько та циркуль--1»).

А наведені на самому початку розбору задачі міркування «дірка-круг №~i~ забороняє Васильку проводити кола з радіусами у проміжку від ~d_i - r_i~ до ~d_i + r_i~, де ~d_i = \sqrt{(x-x_i)^2+(y-y_i)^2}~» означають, що така дірка-круг перетворюється на тій самій «вісі радіусів» у відрізок від ~d_i - r_i~ до ~d_i + r_i~.

Скажімо, приклад з умови перетвориться так.
Є дві дірки-круги.
В однієї центр на відстані ~d_i = \sqrt{20^2+15^2} = 25~ і радіус ~r_i=5~, тому вона створила на «вісі радіусів» відрізок
від ~25-5 = 20~
до ~25+5 = 30~,
у якому Василько не може проводити свої кола.
В іншої центр на відстані ~d_i = \sqrt{50^2+25^2} = 25\sqrt{5} \approx 55,902~ і радіус ~r_i=15~, тому вона створила на «вісі радіусів» відрізок
від ~25\sqrt{5}-15 \approx 40,902~
до ~25\sqrt{5}+15 \approx 70,902~,
у якому Василько не може проводити свої кола.

А відстані до стін та значення ~r=8~, на яке Василько планує щоразу змінювати радіус своїх кіл, задають точки 8, 16, 24, 32. Cеред них, 8, 16, 32 враховуються в остаточну відповідь (кола з такими радіусами проводити можна, бо відповідні цим колам точки на «вісі радіусів» не потрапляють у жоден з відрізків на «вісі радіусів», відповідних діркам-кругам).

Звідси можна бачити, що задачу *«скільки кіл може намалювати Василько?»* можна переформулювати як
*«скільки з точок ~r~, ~2r~, ~3r~, ..., ~K \cdot r~ не потрапляють у жоден з відрізків, відповідних діркам-кругам?»*
(щоправда, з поправкою: перевіряти, що точка ~(x,y)~ не потрапляє ні в яку дірку-круг, треба окремо); як вже сказано, ~K~ означає кількість кіл, знайдену, як у задачі «Василько та циркуль--1».

Хоч і гарантовано, що самі дірки-круги не можуть перетинатися, утворені з них відрізки на «вісі радіусів» цілком можуть: ми ж при переході від початкових прямокутних координат до «вісі радіусів» звертаємо увагу лише на відстані, ігноруючи напрям, а в різних напрямах на приблизно однакових відстанях цілком можуть бути одночасно багато дірок-кругів. На рисунку праворуч зображено ситуація, коли є відразу три дірки-круги, котрі не перетинаються як круги, але відповідні їм відрізки на «вісі радіусів» перетинаються. Очевидно, що їх може бути й ще більше.

Тому, задачу «пошуку точок, що не потрапляють у жоден з відрізків, відповідних діркам-кругам» слід розв'язувати, враховуючи, що такі відрізки можуть хоч не мати спільних точок (вже на «вісі радіусів»), хоч перетинатися частково, хоч коротший може бути повністю вкладеним у довший --- програма мусить правильно враховувати всі ці випадки. Тому зовсім простого алгоритму не виходить.

**100%-й спосіб №1.** Спробуємо розв'язати задачу так.
Перш за все, розберемося, чи справді центр усіх Василькових кіл ~(x,y)~ не потрапляє ні в одну з дірок; якщо потрапляє, виводимо відповідь ``0``; якщо не потрапляє, перетворюємо кожну дірку-круг у відрізок на «вісі радіусів». (Що таке «вісь радіусів» та що таке ~K~, див. вище.) Само собою на «вісі радіусів» є точки ~r~, ~2r~, ~3r~, ..., ~K \cdot r~, відповідні місцям, де Василько міг би проводити кола. Оголосимо їх елементами масиву (від 1-го по ~K~-го, чи від 0-го по ~(K-1)~-й, це неважливо), і нехай ті елементи відповідають на питання *«чи правда, що відповідна точка не потрапляє у жоден відрізок?»*, або, що те саме, *«чи правда, що Василько може провести відповідне коло?»*. Спочатку, ініціалізуємо всі елементи цього масиву значеннями `true`. Потім будемо перебирати зовнішнім циклом відрізки на «вісі радіусів», відповідні діркам-кругам, і для кожного такого відрізка запускати внутрішній цикл, який перетворить з `true` на `false` усі елементи масиву, які потрапляють у відповідний відрізок. Наприкінці лишається тільки порахувати кількість елементів, які лишилися `true`. Або, якщо весь час використовувати цілий, а не логічний, тип (1 замість `true` і 0 замість `false`), то можна порахувати суму масиву.

Правильність цього алгоритму теж більш-менш очевидна (тим, хто зрозумів суть «вісі радіусів»). Але... все одно маємо вкладені цикли, один по кругам-діркам, інший по ~r~, ~2r~, ~3r~, ..., ~K \cdot r~, тільки й того що переставлені місцями відносно очевидного підходу; чому раптом це повинно бути швидше? Хіба цей алгоритм має не ту саму оцінку ~\Theta(N \cdot K)~, про яку раніше говорилося, що з нею можна набрати лише 60% балів?

Виявляється, не зовсім ту саму. По-перше, цей алгоритм треба правильно реалізувати у деталях, зокрема --- не перебирати внутрішнім циклом *усі*
1, 2, 3, ..., ~K~ чи
0, 1, 2, ..., ~K-1~, відповідні
~r~, ~2r~, ~3r~, ..., ~K \cdot r~; слід починати з ~$\approx \frac{d_i-r_i}{r}$~ і закінчувати, коли досягається ~$\approx \min(K, \frac{d_i+r_i}{r})$~, тобто переглядати лише ті елементи, яким справді треба надати `false` чи `0`.

Може здатися, ніби це якась дивна оптимізація, бо «вона нічого не дасть, якщо для майже кожного з відрізків доведеться пробігти майже увесь діапазон масиву». Що ж, для таких відрізків така оптимізація справді нічого (чи майже нічого) не дала б. Але насправді ***не може бути водночас багато довгих відрізків***. Бо відрізки в нас не любо-які, а утворені з дірок-кругів, причому дірки-круги не перетинаються.

Наприклад, праворуч зображено, що якби всі дірки-круги мали радіус ~0,4 \cdot K \cdot r~ (відповідно, відрізки на «вісі радіусів» займали 80% проміжку від 0 до ~K \cdot r~; смисл ~K~ див. вище) і мусіли повністю розміщуватися всередині останнього кола радіусом ~K \cdot r~, то їх помістилось би щонайбільше 3 (три) штуки; аналогічно, для ~0,3 \cdot K \cdot r~ щонайбільше 7 (сім) штук (додати ще одну посередині не можна, бо спільний центр всіх Василькових кіл потрапив би у дірку).

Само собою, за рахунок того, що дірки-круги можуть бути різних радіусів, а також можуть потрапляти у коло радіуса ~K \cdot r~ лише частково (маючи помітну свою частину ззовні), замість наведених 3 чи 7 дірок-кругів їх може бути й більше. Але значно більше --- лише за рахунок значного зменшення розміру більшості дірок-кругів, і загальний приблизний висновок «не може бути водночас багато довгих відрізків» від цього не порушується. А це означає, що асимптотична оцінка ~\Theta(N \cdot K)~ сильно завищена, насправді програму можна реалізувати так, щоб вона працювала значно швидше. На жаль, виразити теоретично правильну асимптотичну оцінку досить складно. Але виявляється, що акуратна в деталях реалізація цього алгоритма проходить усі тести. (Хоча, якщо чесно, початковий намір автора задачі був, щоб такий алгоритм не проходив останній блок.)

**А якщо координати будуть значно більші, як-то до ~10^{18}~? (100%-й спосіб №2.)**
Попередній алгоритм справді не дуже добрий тим, що час його роботи залежить від значень координат. Тому й пропонується розглянути також наступний алгоритм. Щоб це стало справді важливим, значення координат треба істотно збільшити... але тоді стане важливим такий чинник, як похибки обчислень. Якщо при координатах до ~10^7~ майже всі математично-правильні обчислення, виконані у стандартному типі даних з рухомою комою (floating point), не матимуть особливих проблем через похибки, то при більших значеннях з цим усе значно гірше та складніше. Тому й вийшло, що задача дана з обмеженнями, при яких наступний алгоритм не має істотних переваг над попереднім, хоча, якби додатково збільшили значення координат, наступний алгоритм мав би значні переваги над попереднім і за швидкістю виконання, і за обсягом використаної пам'яті.

Розглянемо ту саму «вісь радіусів», але не будемо пов'язувати її з масивом. Натомість, розглянемо на ній більш-менш відому задачу «міра об'єднання відрізків на прямій», що розв'язується методом, який називають «вимітанням», «замітанням», «методом сканувальної прямої»; це все різні назви одного й того ж методу. Він розглянутий у багатьох джерелах (одне з таких джерел --- [змагання №54](https://ejudge.ckipo.edu.ua/cgi-bin/new-register?contest_id=54)), тому не пояснюватимемо його справді детально. Але короткий опис, поєднаний із конкретним прикладом, розглянемо. Нехай маємо вхідні дані, зображені на рис. Наведені там дірки-круги перетворюються у відрізки на «вісі радіусів»
~$\sqrt{22^2+0^2} \pm 5 = [17 \ldots 27]$~,
~$\sqrt{18^2+20^2} \pm 7 \approx [19,907 \ldots 33,907]$~,
~$\sqrt{18^2+10^2} \pm 2 \approx [18,591 \ldots 22,591]$~ та
~$\sqrt{25^2+35^2} \pm 5 \approx [38,012 \ldots 48,012]$~,
зображені нижче.
Якщо відсортувати всі координати початків та кінців таких відрізків (спільним масивом, але так, щоб після сортування було ясно, де початки й де кінці), можна йти зліва направо, перебираючи не значення окремих координат, а лише «точки подій», якими є: 0; відсортовані координати тих початків та кінців, які потрапили в проміжок від 0 до ~K \cdot r~; координата ~K \cdot r~.
При цьому слід підтримувати певну змінну, яку часто називають «статус»; конкретно у цій задачі «статус» є цілим невід'ємним числом; він спочатку рівний 0, потім на кожному початку відрізка збільшується на 1, на кожному кінці відрізка зменшується на 1. Отже, точки не належать жодному відрізку там і лише там, де статус=0.
Щоразу, коли статус змінюється з 0 на 1, потрібно порахувати (за формулою, без циклу), скільки було координат, кратних ~r~, до цієї точки, після попередньої (причому, попередня обов'язково є або координатою 0 (початком «вісі радіусів»), або такою, де статус змінювався з 1 на 0).