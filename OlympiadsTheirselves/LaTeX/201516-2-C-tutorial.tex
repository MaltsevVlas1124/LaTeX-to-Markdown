\Tutorial	
\label{label:find-n-th-perm-with-rep-begin}
Задача має багато спільного з задачею <<Генератор паролiв>> (стор.~\pageref{label:201415-3-C-start}--\pageref{label:201415-3-C-finish}). Тут теж варто знайти, скільки всього можливих послідовностей починається з~`\texttt{A}' і\nolinebreak[3] або побачити, що\nolinebreak[3] задане у~вхідних даних~$n$~$\<$ цієї кількості (тоді послідовність-відповідь починається\nolinebreak[3] з~`\texttt{A}' і слід продовжити підбирати літери на подальших позиціях), або, у\nolinebreak[3] протилежному випадку, слід відняти з заданого у~вхідних даних~$n$ кількість цих послідовностей (що\nolinebreak[3] починаються з~`\texttt{A}') і зробити те~с\'{а}ме щодо послідовностей, що\nolinebreak[3] починаються з~`\texttt{B}',\nolinebreak[3] `\texttt{C}',~`\texttt{D}'.

Тож треба % навчитися 
знаходити кількість послідовностей, 
% які 
що
починаються з такої-то послідовності літер (і\nolinebreak[3] тому відомо, з\nolinebreak[3] яких літер у\nolinebreak[3] яких кількостях складаються можливі продовження). Виборки, де всі елементи розставляють усіма можливими порядками, не~змінюючи набір цих елементів, називають \emph{перестановками} (\emph{permutations}). Якщо у\nolinebreak[3] наборі елементів, які переставляють, є однакові (наприклад, ``\texttt{ABCB}'', причому, якщо обміняти місцями одне~`\texttt{B}' з іншим~`\texttt{B}', це вважається тим самим способом), то виборки називають \emph{перестановками з~повтореннями}, і їх кількість може бути виражена як

\vspace{-0.5\baselineskip}

$$
\overline{P}(k_1, k_2, \dots, k_n) = \frac{(k_1+k_2+\dots+k_n)!}{k_1!\cdot{}k_2!\cdot\ldots\cdot{}k_n!},
$$ 

\vspace{-0.5\baselineskip}

\noindent
де ``!'' означає факторіал, $k_1$, $k_2$,~\dots,\nolinebreak[2] $k_n$\nolinebreak[3] --- кількості елементів кожного типу. (Звідки береться ця формула? Пропонуємо знайти у\nolinebreak[3] літературі чи\nolinebreak[3] Інтернеті; при розв'язуванні задачі це не~потрібне, досить знати сам\'{у} формулу; але виведення і~допомагає її запам'ятати, і~може бути корисним у інших ситуаціях.) 
В~цій задачі, формула набуває вигляду 
$\overline{P}(a, b, c, d) \dib{{=}} \ifBigStretch\displaystyle\fi\frac{(a+b+c+d)!}{a!\cdot{}b!\cdot{}c!\cdot{}d!}$.


Лишається тільки поєднати розглянуті міркування. Зробіть це самостійно. А\nolinebreak[3] для контролю правильності розглянемо приклад
${a\,{=}\,1}$,
${b\,{=}\,2}$,
${c\,{=}\,3}$,
${d\,{=}\,4}$,
${n\,{=}\,2015}$.

\ifAfour
\begin{small}
\fi

При початку на~`\texttt{A}', можливих продовжень 
$\overline{P}(0,2,3,4)$, бо якщо взяти на першу позицію~`\texttt{A}', на подальші позиції не~лишається жодної~`\texttt{A}', 
${b\,{=}\,2}$~штук~`\texttt{B}',
${c\,{=}\,3}$~штук~`\texttt{C}',
${d\,{=}\,4}$~штук~`\texttt{D}'.
$\ifBigStretch\displaystyle\fi\frac{(0+2+3+4)!}{0!\cdot2!\cdot3!\cdot4!}\dib{{=}}1260\dib{{<}}2015$, тобто відповідь починається не\nolinebreak[3] на~`\texttt{A}', а\nolinebreak[3] на\nolinebreak[3] одну з\nolinebreak[3] подальших літер, і\nolinebreak[3] номер відповіді серед тих подальших дорівнює $2015\dib{{-}}1260\dib{{=}}755$.

При початку на~`\texttt{B}', можливих продовжень 
$\overline{P}(1,1,3,4)$, бо якщо взяти на першу позицію~`\texttt{B}', на подальші позиції лишається 
${a\,{=}\,1}$~штука~`\texttt{A}',
${b\,{=}\,1}$~штука~`\texttt{B}',
${c\,{=}\,3}$~штук~`\texttt{C}',
${d\,{=}\,4}$~штук~`\texttt{D}'.
$\ifBigStretch\displaystyle\fi\frac{(1+1+3+4)!}{1!\cdot1!\cdot3!\cdot4!}\dib{{=}}2520\dib{{\>}}755$, тобто відповідь починається якраз на~`\texttt{B}', і\nolinebreak[3] треба шукати подальші літери.

При початку на~``\texttt{BA}'', можливих продовжень 
$\overline{P}(0,1,3,4)$, бо якщо взяти на перші дві позиції\nolinebreak[3] ``\texttt{BA}'', на подальші позиції лишається 
${a\,{=}\,0}$~штук~`\texttt{A}',
${b\,{=}\,1}$~штука~`\texttt{B}',
${c\,{=}\,3}$~штук~`\texttt{C}',
${d\,{=}\,4}$~штук~`\texttt{D}'.
$\ifBigStretch\displaystyle\fi\frac{(0+1+3+4)!}{0!\cdot1!\cdot3!\cdot4!}\dib{{=}}280\dib{{<}}755$, тобто відповідь починається не\nolinebreak[3] на\nolinebreak[3] ``\texttt{BA}'', а\nolinebreak[3] має на другій позиції одну з\nolinebreak[3] подальших літер, і\nolinebreak[3] номер відповіді серед тих подальших дорівнює $755\dib{{-}}280\dib{{=}}475$.

При початку на~``\texttt{BB}'', можливих продовжень 
$\overline{P}(1,0,3,4)\dib{{=}}280\dib{{<}}475$, тож відповідь починається не\nolinebreak[3] на\nolinebreak[3] ``\texttt{BB}'', а\nolinebreak[3] має на другій позиції одну з\nolinebreak[3] подальших літер, і\nolinebreak[3] номер серед тих подальших рівний $475\dib{{-}}280\dib{{=}}195$.

При початку ``\texttt{BС}'', можливих продовжень
$\overline{P}(1,1,2,4)\dib{{=}}\ifBigStretch\displaystyle\fi\frac{(1+1+2+4)!}{1!\cdot1!\cdot2!\cdot4!}\dib{{=}}840\dib{{\>}}195$, тож відповідь починається якраз на~`\texttt{BC}'.

При початку ``\texttt{BСA}'', можливих продовжень
$\overline{P}(0,1,2,4)\dib{{=}}\ifBigStretch\displaystyle\fi\frac{\ifAfour(0+1+2+4)!\else(0{+}1{+}2{+}4)!\fi}{0!\cdot1!\cdot2!\cdot4!}\dib{{=}}105\dib{{<}}195$, тож відповідь має на третій позиції одну з\nolinebreak[3] подальших літер, номер серед подальших $195\dib{{-}}105\dib{{=}}90$.

При початку ``\texttt{BСB}'', можливих продовжень
$\overline{P}(1,0,2,4)\dib{{=}}105\dib{{\>}}90$, тож відповідь починається % якраз 
на~`\texttt{BCB}'.

При початку ``\texttt{BСBA}'', можливих продовжень
$\overline{P}(0,0,2,4)\dib{{=}}\ifBigStretch\displaystyle\fi\frac{(0{+}0{+}2{+}4)!}{0!\cdot0!\cdot2!\cdot4!}\dib{{=}}15\dib{{<}}90$, тож відповідь має на четвертій позиції одну з\nolinebreak[3] подальших літер, номер серед подальших $90\dib{{-}}15\dib{{=}}75$.

Тепер треба правильно врахувати (наприклад, передбачити \verb"if" для таких ситуацій), що літер~`\texttt{B}' спочатку було лише ${b\,{=}\,2}$ й тому початок ``\texttt{BСBB}'' взагалі неможливий (кіль\-\mbox{кість$\,$=$\,$0}) і тому треба продовжити, перейшовши до ``\texttt{BСBC}''. 

І~так~далі. Остат\'{о}чна відповідь\nolinebreak[3] --- \mbox{``\texttt{BCBDDCDCAD}''}.

\ifAfour
\end{small}
\fi

У~тексті це займає багато місця, але виконується такий алгоритм дуже швидко\nolinebreak[3] --- сумарна % (по\nolinebreak[3] усім реально потрібним наборам аргументів) 
кількість обчислень формули~$\overline{P}(\dots)$ не~перевищує $4\dibbb{{\times}}{(a\,{+}\,b\,{+}\,c\,{+}\,d)}$ (бо\nolinebreak[3] кількість розрядів ${a\,{+}\,b\,{+}\,c\,{+}\,d}$, у~кожному пробуються, щонайбільше, 
`\texttt{A}',~`\texttt{B}',\nolinebreak[3]
`\texttt{C}',~`\texttt{D}'), тож загальна кількість дій може бути виражена як ${O((a\,{+}\,b\,{+}\,c\,{+}\,d)^2)}$ навіть при не~найкращій реалізації самої формули, яка щоразу заново переобчислює факторіали; якщо ж зберігати готові факторіали, можна оптимізувати усю разом узяту програму до ${\Theta(a\,{+}\,b\,{+}\,c\,{+}\,d)}$ (втім, при настільки малих $a$, $b$, $c$, $d$ це несуттєво).\label{label:find-n-th-perm-with-rep-end}




\MyParagraph{Як легко й просто набрати 60\% балів (лише~C++).}
У~бібліотеці \verb"algorithm" мови~C++ є функція \verb"next_permutation", яка дозволяє послідовно перебирати перестановки у порядку зростання (що й треба у цій задачі), і яка правильно працює з будь-якими перестановками (з\nolinebreak[3] повтореннями чи\nolinebreak[3] без). Так що можна сформувати \verb"string s" зі значенням ``$
\underbrace{\texttt{AA}\dots\texttt{A}}_{\textnormal{\begin{footnotesize}$a$~штук\end{footnotesize}}}
\underbrace{\texttt{BB}\dots\texttt{B}}_{\textnormal{\begin{footnotesize}$b$~штук\end{footnotesize}}}
\underbrace{\texttt{CC}\dots\texttt{C}}_{\textnormal{\begin{footnotesize}$c$~штук\end{footnotesize}}}
\underbrace{\texttt{DD}\dots\texttt{D}}_{\textnormal{\begin{footnotesize}$d$~штук\end{footnotesize}}}
$'' і $n{-}1$ разів застосувати \verb"next_permutation(s.begin(), s.end());". Складність такого алгоритму становить $\Theta(n)$ (причому, \verb"next_permutation", хоч і має амортизовану складність $\Theta(1)$, не~дуже швидка), тож він ніяк не може бути досить ефективним при $n\dib{{\approx}}\overline{P}(5,5,5,5)\dib{{=}}\ifBigStretch\displaystyle\fi\frac{20!}{5!\cdot5!\cdot5!\cdot5!}\dib{{\approx}}{1{,}173\cdot10^{10}}$. 
%%% В~умові цієї задачі не\nolinebreak[3] описано, скільки балів на які діапазони вхідних даних припадає, тож з~умови не~ясно, що це с\'{а}ме\nolinebreak[2] 60\%; але очевидно, що якісь бали мусять бути.
В~умові задачі нема розбаловки, тож не~ясно, що це с\'{а}ме\nolinebreak[2] 60\%; але очевидно, що якісь бали мусять бути.

\MyParagraph{А інші?} Автори збірника не~впевнені, чи~достатньо дослідили бібліотеки інших % доступних на олімпіаді 
мов програмування, але хоч трохи схожі % стандартні 
засоби вдалося знайти лише у Python (клас \texttt{permutations} модуля \texttt{itertools}). Причому, цей клас не~так, як~треба, працює з повтореннями елементів, тож невідомо, як використати його краще, ніж \texttt{a~= list(set(permutations(s)))}, \texttt{a.sort()}, тобто спочатку згенерувати геть усі перестановки (звичайні), потім використати \texttt{set}, щоб позбутися повторень, потім перетворити у масив (\texttt{list}) і відсортувати. Все\nolinebreak[3] це, звісно, працює \emph{набагато} довше, головним чином, том\'{у}, що на проміжному етапі генеруються перестановки без повторень, а їх може бути значно 
більше: наприклад, при ${a\,{=}\,b\,{=}\,4}$, ${c\,{=}\,d\,{=}\,3}$ маємо $14!\dib{{\approx}}8{,}7{\cdot}10^{10}$ (причому їх треба ще й % згеренувати всі й 
одночасно тримати у пам'яті) %, що категорично неможливо) 
проти $\frac{14!}{4!4!3!3!}\dib{{\approx}}4{,}2{\cdot}10^6$ (що\nolinebreak[2] для\nolinebreak[2] комп'ютера небагато, причому вони перебираються одна за одною, % як~правило не~доходячи до кінця, й ніколи 
не~займаючи багато пам'яті).
%
Цей спосіб набирає 40\% балів.

% Втім, свої 40\% балів цей спосіб на Python все-таки набирає.

\MyParagraph{А ще інші?} На\nolinebreak[3] жаль, для ще інших мов програмування важко запропонувати простий спосіб набрати навіть таку частину балів. 
Це\nolinebreak[3] сумно, але: 
\linebreak[3]
(1)~100\%-й алгоритм можна написати будь-якою з доступних мов програмування; 
\linebreak[3]
(2)~нікому з учасників не\nolinebreak[3] заборонялося вчити й використовувати\nolinebreak[3] C++.

Писати власний аналог \verb"next_permutation" не~доцільно, бо потреб\'{у}є майже стільки\nolinebreak[3] ж зусиль, як ефективний розв'язок початкової задачі, а~принести може, щонайбільше, ті~ж\nolinebreak[2] 60\%\nolinebreak[3] балів. Тим не~менш, кому цікаво, може знайти у літературі чи Інтернеті \emph{алгоритми генерації перестановок}. 
%
Є~кілька різних класичних алгоритмів такої генерації. І\nolinebreak[3] \emph{одні} з них (які визначають, що поміняти у поточній перестановці, щоб перейти до наступної) оптимізовані під відносно швидшу організацію перебору усіх підряд перестановок (у\nolinebreak[3] \verb"next_permutation" с\'{а}ме такий). А\nolinebreak[3] \emph{інші} (зокрема, рекурсивні) дозволяють вписування додаткових умов, щоб пропускати непотрібні. Говорячи про цю задачу, такі модифікації можна кінець кінцем перетворити до рекурсивної версії 
% способу зі стор.~\pageref{label:find-n-th-perm-with-rep-begin}--\pageref{label:find-n-th-perm-with-rep-end}\dots
рекомендованого способу.
