Завдання в цілому аналогічне завданню «Структура (колекція) set» (і наполегливо рекомендується зробити спочатку його), але елементами повинні бути не числа, а дещо складніші об'єкти: прямокутники, кожен з яких описується довжинами двох своїх сторін {\it a}, {\it b} (два цілі числа) та кольором ({\tt string}) {\it col}. Повертати прямокутники дозволено ({\it b}×{\it a} — те само, що {\it a}×{\it b}), а колір враховується. Інакше кажучи, елемент-прямокутник належить множині тоді й тільки тоді, коли множина містить елемент-прямокутник, в якого такі самі розміри, але порядок цих розмірів може бути хоч таким самим, хоч переставленим; при цьому колір повинен бути таким самим (у смислі звичайної case-sensitive рівності рядків).

Кожен із запитів {\tt ADD} та/або {\tt PRESENT} має по три параметри {\it a b col}, саме в такому порядку. Вони задаються в одному рядку через пробіли.

Напишіть програму, яка виконуватиме послідовність запитів виду {\tt ADD} {\it a b col}, {\tt PRESENT} {\it a b col} та {\tt COUNT} (без параметрів). Програму обов'язково слід писати за допомогою бібліотечного типу (колекції) set (її реалізації в~конкретних мовах програмування можуть називатися {\tt HashSet}, {\tt TreeSet}, {\tt SortedSet},~\dots).

Виконання кожного запиту виду {\tt ADD} {\it a b col} повинно додавати прямокутник до множини (якщо такий само прямокутник вже є, додавання ще однієї копії не змінює множину). На екран при цьому нічого не виводиться.

При виконанні кожного запиту виду {\tt PRESENT} {\it a b col} має видаватися повідомлення {\tt YES} або {\tt NO} (великими літерами, в~окремому рядку), відповідно до того, чи~є такий елемент-прямокутник у множині; значення множини при цьому не~змінюється.

При виконанні кожного запиту виду {\tt COUNT} має видаватися на екран в~окремому рядку кількість різних елементів-прямокутників у~множині; значення множини при цьому не~змінюється.


\InputFile

У першому рядку задано кількість запитів $N$ ($5\leqslant N\leqslant 2\cdot10^5$), далі йдуть $N$ рядків, кожен з яких містить по одному запиту згідно з описаним форматом. Всі параметри {\it a} та {\it b} є цілими числами від 1 до 1234567890. Всі параметри {\it col} є рядками, що містять від 1 до 15 латинських (англійських) літер, без будь-яких інших символів. 



\OutputFile

Виводьте окремими рядками результати запитів {\tt PRESENT} (рівно одне «YES» чи «NO» великими буквами) та {\tt COUNT} (рівно одне число); на запити {\tt ADD} нічого не~виводьте.


\Examples

\begin{example}
\exmp{11
ADD 5 2 red
COUNT
PRESENT 5 2 red
PRESENT 5 2 ReD
PRESENT 2 5 red
ADD 2 5 green
COUNT
ADD 2 5 red
COUNT
ADD 5 2 red
COUNT}{1
YES
NO
YES
2
2
2}
\end{example}

\Note

Перша відповідь {\tt 1} правильна, бо на той момент множина містить рівно один елемент-прямокутник {\tt 5 2 red}.

Друга відповідь {\tt YES} правильна, бо коли питають про наявність прямокутника, з такими самими розмірами {\tt 5 2} в такому ж порядку, причому такого самого кольору {\tt red}, то він вже наявний.

Третя відповідь {\tt NO} правильна, бо хоч розміри {\tt 5 2} такі самі в такому ж порядку, але колір інший (case-sensitive передбачає, що {\tt ReD} не дорівнює {\tt red}).

Четверта відповідь {\tt YES} правильна, бо розміри {\tt 2 5} і є тими самим числами (хоч і в іншому порядку), що й {\tt 5 2}, і колір правильний.

П'ята відповідь {\tt 2} правильна, бо перед тим був запит {\tt ADD} з елементом-прямокутником, що відрізняється від вже наявного кольором, тому тоді його додали, від чого кількість елементів множини змінилася.

Шоста відповідь {\tt 2} правильна, бо перед тим був запит {\tt ADD} з елементом-прямокутником {\tt 2 5 red}, що (незважаючи на переставляння місцями чисел) вважається рівним одному з уже наявних у множині прямокутників {\tt 5 2 red}, тому множина не змінилася й продовжує містити рівно 2 елементи-прямокутники.

Сьома відповідь {\tt 2} правильна, бо перед тим був запит {\tt ADD} з елементом-прямокутником, за всіма ознаками рівним вже наявному (найпершому) елементу-прямокутнику, тому множина не змінилася й продовжує містити рівно 2 елементи-прямокутники.

Абсолютно повне виконання завдання передбачає, що воно виконане і через бібліотечну колекцію {\tt HashSet} (з написанням власних {\tt GetHashCode} та {\tt Equals}), і через бібліотечну колекцію {\tt SortedSet} (з написанням власного компаратора). В разі виконання іншою мовою програмування, з'ясуйте відповідні деталі самостійно, але це повинен бути бібліотечний спосіб через хеш-таблиці та бібліотечний спосіб через дерева. Само собою, можна виконати частину, на відповідну частину балів. 


