{\it
Ця задача повністю включає в себе попередню задачу «Дерева (вставка, пошук)».
Тому, в~разі виникнення проблем із розв'язуванням цієї задачі, рекомендується спочатку зробити попередню, а також прочитати примітку наприкінці умови цієї задачі.
}

Напишіть програму, яка реалізовуватиме у бінарному дереві пошуку дії «вставити» та «знайти» (за~значенням). Програма повинна виконувати  послідовність запитів вигляду ``{\tt ADD} {\it n}'', ``{\tt SEARCH} {\it n}'', ``{\tt DELETE} {\it n}'' та ``{\tt PRINTTREE}'', де {\it n} --- натуральне число.

Для кожного запиту ``{\tt ADD} {\it n}'' слід виконати такі дії: якщо вказаного числа ще нема в дереві, вставити у дерево і вивести на екран слово ``{\tt DONE}'', якщо вже є --- залишати дерево як було (не~вставляти додаткову копію) і виводити на екран слово ``{\tt ALREADY}''.

Для кожного запиту ``{\tt SEARCH} {\it n}'' слід вивести на екран слово ``{\tt YES}'' (якщо значення знайдене у дереві) або слово ``{\tt NO}'' (якщо не~знайдене); при виконанні запитів {\tt SEARCH} дерево не~змінюється.

Для кожного запиту ``{\tt DELETE} {\it n}'' слід виконати такі дії: якщо вказане число є в дереві, вилучити його з дерева і вивести на екран слово ``{\tt DONE}'', якщо нема — залишати дерево як було і виводити на екран слово ``{\tt CANNOT}''. При видаленні елемента, що має обох синів, обов’язково обмінювати значення з максимальним елементом лівого піддерева.

Для кожного запиту ``{\tt PRINTTREE}'' слід вивести на екран усе дерево, обов’язково дотримуючись того ж формату, що й наведений далі алгоритм.

\InputFile
В кожному рядку вхідних даних записаний один із запитів ``{\tt ADD} {\it n}'', або ``{\tt SEARCH} {\it n}'', або ``{\tt DELETE} {\it n}'', або ``{\tt PRINTTREE}'' (без лапок; слова записані великими латинськими буквами; для запитів {\tt ADD}, {\tt SEARCH} та {\tt DELETE} число відділене від слова одинарним пробілом і перебуває в межах від 1 до 1234567890). Гарантується, що запити {\tt PRINTTREE} будуть лише у моменти, коли дерево не~порожнє. Загальна кількість запитів не~перевищує~1000, з них не~більше~20 запитів {\tt PRINTTREE}.

\OutputFile
Для кожного запиту виводити відповідь на нього. Для запитів {\tt ADD} та {\tt SEARCH} --- відповідне слово в окремому рядку (великими латинськими буквами, без лапок). На запит {\tt  PRINTTREE} треба виводити дерево, обов’язково відповідно до такого алгоритму:

\begin{verbatim}
public void PrintTree(Node root, int level)
{
    if (root == null)
        return;
    PrintTree(root.left, level + 1);
    Console.WriteLine(new String('.', level) + root.Data);
    PrintTree(root.right, level + 1);
}
\end{verbatim}

% {\tt\\
% public void PrintTree(Node root, int level)\\
% \{\\
% ~~~~if (root == null)\\
% ~~~~~~~~return;\\
% ~~~~PrintTree(root.left, level + 1);\\
% ~~~~Console.WriteLine(new String('.', level) + root.Data);\\
% ~~~~PrintTree(root.right, level + 1);\\
% \}
% }

(Початковий виклик цього методу --- {\tt PrintTree(root,~0)}. Якщо описати цей алгоритм словами, вийде приблизно так: слід виводити спочатку ліве піддерево, потім корінь, потім праве піддерево, і результат виходить впорядкованим згори донизу так, як при класичному зображенні мав би бути впорядкований зліва направо; перед кожним елементом треба виводити стільки крапочок, який це ярус, вважаючи, що корінь є єдиним елементом ярусу 0 (слід взагалі не ставити крапочок), сини кореня є елементами ярусу~1 (слід поставити рівно одну крапочку), «онуки» (сини синів) кореня є елементами ярусу~2 (слід поставити рівно дві крапочки), і так далі.) 

\Examples

\begin{example}
\exmp{ADD 2
ADD 7
ADD 5
PRINTTREE
ADD 5
DELETE 3
ADD 1
PRINTTREE
DELETE 7
PRINTTREE}{DONE
DONE
DONE
2
..5
.7
ALREADY
CANNOT
DONE
.1
2
..5
.7
DONE
.1
2
.5}
\end{example}

\Note
1)
Враховувати вищезгадану фразу «При видаленні елемента, що має обох синів, обов’язково обмінювати значення з максимальним елементом лівого піддерева.», на жаль, абсолютно необхідно для зарахування розв'язку. Попри те, що це взагалі-то не є об'єктивно необхідним для непротирічивості дерева (цей спосіб правильний, але є й інші правильні способи). Однак, у цій задачі все-таки необхідно застосувати саме конкретно цей спосіб, бо конкретно в ній визначення правильності Вашої програми робиться просто порівнянням її відповіді зі зразком (без глибшого аналізу смислу), і це переписуватися не буде. Кому це не подобається --- може просто не робити цю задачу.

2)
Одна з відносно частих помилок при виконанні цієї задачі --- написаний студентом код помилково виводить два повідомлення {\tt YES} замість одного при успішному видаленні елемента, що має обох синів. Переконайтеся, що у Вашого коду нема конкретно цієї проблеми.